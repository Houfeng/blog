<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Houfeng&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.houfeng.net/"/>
  <updated>2016-08-27T03:30:16.000Z</updated>
  <id>http://blog.houfeng.net/</id>
  
  <author>
    <name>Houfeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 之 “ArrayBuffer对象”</title>
    <link href="http://blog.houfeng.net/2015/07/15/2014-10-15-javascript-arraybuffer/"/>
    <id>http://blog.houfeng.net/2015/07/15/2014-10-15-javascript-arraybuffer/</id>
    <published>2015-07-15T07:32:08.000Z</published>
    <updated>2016-08-27T03:30:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>类型化数组是JavaScript操作二进制数据的一个接口。<br>这要从WebGL项目的诞生说起，所谓WebGL，就是指浏览器与显卡之间的通信接口，为了满足JavaScript与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。<br>比如，以文本格式传递一个32位整数，两端的JavaScript脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像C语言那样，直接操作字节，然后将4个字节的32位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。<br>类型化数组（Typed Array）就是在这种背景下诞生的。它很像C语言的数组，允许开发者以数组下标的形式，直接操作内存。有了类型化数组以后，JavaScript的二进制数据处理功能增强了很多，接口之间完全可以用二进制数据通信。</p>
<a id="more"></a>
<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>类型化数组是建立在ArrayBuffer对象的基础上的。它的作用是，分配一段可以存放数据的连续内存区域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">32</span>);</div></pre></td></tr></table></figure>
<p>上面代码生成了一段32字节的内存区域。</p>
<p>ArrayBuffer对象的<strong>byteLength属性</strong>，返回所分配的内存区域的字节长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">32</span>);</div><div class="line">buffer.byteLength</div><div class="line"><span class="comment">// 32</span></div></pre></td></tr></table></figure>
<p>如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (buffer.byteLength === n) &#123;</div><div class="line">  <span class="comment">// 成功</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 失败</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ArrayBuffer对象有一个<strong>slice方法</strong>，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> newBuffer = buffer.slice(<span class="number">0</span>,<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>上面代码拷贝buffer对象的前3个字节，生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。</p>
<p>slice方法接受两个参数，第一个参数表示拷贝开始的字节序号，第二个参数表示拷贝截止的字节序号。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。</p>
<p>除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="视图的生成"><a href="#视图的生成" class="headerlink" title="视图的生成"></a>视图的生成</h3><p>ArrayBuffer作为内存区域，可以存放多种类型的数据。不同数据有不同的存储方式，这就叫做“视图”。目前，JavaScript提供以下类型的视图：</p>
<ul>
<li><strong>Int8Array</strong>：8位有符号整数，长度1个字节。</li>
<li><strong>Uint8Array</strong>：8位无符号整数，长度1个字节。</li>
<li><strong>Int16Array</strong>：16位有符号整数，长度2个字节。</li>
<li><strong>Uint16Array</strong>：16位无符号整数，长度2个字节。</li>
<li><strong>Int32Array</strong>：32位有符号整数，长度4个字节。</li>
<li><strong>Uint32Array</strong>：32位无符号整数，长度4个字节。</li>
<li><strong>Float32Array</strong>：32位浮点数，长度4个字节。</li>
<li><strong>Float64Array</strong>：64位浮点数，长度8个字节。</li>
</ul>
<p>每一种视图都有一个BYTES_PER_ELEMENT常数，表示这种数据类型占据的字节数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Int8Array</span>.BYTES_PER_ELEMENT <span class="comment">// 1</span></div><div class="line"><span class="built_in">Uint8Array</span>.BYTES_PER_ELEMENT <span class="comment">// 1</span></div><div class="line"><span class="built_in">Int16Array</span>.BYTES_PER_ELEMENT <span class="comment">// 2</span></div><div class="line"><span class="built_in">Uint16Array</span>.BYTES_PER_ELEMENT <span class="comment">// 2</span></div><div class="line"><span class="built_in">Int32Array</span>.BYTES_PER_ELEMENT <span class="comment">// 4</span></div><div class="line"><span class="built_in">Uint32Array</span>.BYTES_PER_ELEMENT <span class="comment">// 4</span></div><div class="line"><span class="built_in">Float32Array</span>.BYTES_PER_ELEMENT <span class="comment">// 4</span></div><div class="line"><span class="built_in">Float64Array</span>.BYTES_PER_ELEMENT <span class="comment">// 8</span></div></pre></td></tr></table></figure>
<p>每一种视图都是一个构造函数，有多种方法可以生成：</p>
<p><strong>（1）在ArrayBuffer对象之上生成视图。</strong></p>
<p>同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 创建一个8字节的ArrayBuffer</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾</span></div><div class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(b);</div><div class="line"></div><div class="line"><span class="comment">// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾</span></div><div class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(b, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建一个指向b的Int16视图，开始于字节2，长度为2</span></div><div class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(b, <span class="number">2</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>上面代码在一段长度为8个字节的内存（b）之上，生成了三个视图：v1、v2和v3。视图的构造函数可以接受三个参数：</p>
<ul>
<li>第一个参数：视图对应的底层ArrayBuffer对象，该参数是必需的。</li>
<li>第二个参数：视图开始的字节序号，默认从0开始。</li>
<li>第三个参数：视图包含的数据个数，默认直到本段内存区域结束。</li>
</ul>
<p>因此，v1、v2和v3是重叠：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。</p>
<p><strong>（2）直接生成。</strong></p>
<p>视图还可以不通过ArrayBuffer对象，直接分配内存而生成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> f64a = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="number">8</span>);</div><div class="line">f64a[<span class="number">0</span>] = <span class="number">10</span>;</div><div class="line">f64a[<span class="number">1</span>] = <span class="number">20</span>;</div><div class="line">f64a[<span class="number">2</span>] = f64a[<span class="number">0</span>] + f64a[<span class="number">1</span>];</div></pre></td></tr></table></figure>
<p>上面代码生成一个8个成员的Float64Array数组（共64字节），然后依次对每个成员赋值。这时，视图构造函数的参数就是成员的个数。可以看到，视图数组的赋值操作与普通数组的操作毫无两样。</p>
<p><strong>（3）将普通数组转为视图数组。</strong></p>
<p>将一个数据类型符合要求的普通数组，传入构造函数，也能直接生成视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> typedArray = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ] );</div></pre></td></tr></table></figure>
<p>上面代码将一个普通的数组，赋值给一个新生成的8位无符号整数的视图数组。</p>
<p>视图数组也可以转换回普通数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> normalArray = <span class="built_in">Array</span>.apply( [], typedArray );</div></pre></td></tr></table></figure>
<h3 id="视图的操作"><a href="#视图的操作" class="headerlink" title="视图的操作"></a>视图的操作</h3><p>建立了视图以后，就可以进行各种操作了。这里需要明确的是，视图其实就是普通数组，语法完全没有什么不同，只不过它直接针对内存进行操作，而且每个成员都有确定的数据类型。所以，视图就被叫做“类型化数组”。</p>
<p><strong>（1）数组操作</strong></p>
<p>普通数组的操作方法和属性，对类型化数组完全适用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> int32View = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buffer);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;int32View.length; i++) &#123;</div><div class="line">  int32View[i] = i*<span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码生成一个16字节的ArrayBuffer对象，然后在它的基础上，建立了一个32位整数的视图。由于每个32位整数占据4个字节，所以一共可以写入4个整数，依次为0，2，4，6。</p>
<p>如果在这段数据上接着建立一个16位整数的视图，则可以读出完全不一样的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> int16View = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;int16View.length; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Entry "</span> + i + <span class="string">": "</span> + int16View[i]);</div><div class="line">&#125;</div><div class="line"><span class="comment">// Entry 0: 0</span></div><div class="line"><span class="comment">// Entry 1: 0</span></div><div class="line"><span class="comment">// Entry 2: 2</span></div><div class="line"><span class="comment">// Entry 3: 0</span></div><div class="line"><span class="comment">// Entry 4: 4</span></div><div class="line"><span class="comment">// Entry 5: 0</span></div><div class="line"><span class="comment">// Entry 6: 6</span></div><div class="line"><span class="comment">// Entry 7: 0</span></div></pre></td></tr></table></figure>
<p>由于每个16位整数占据2个字节，所以整个ArrayBuffer对象现在分成8段。然后，由于x86体系的计算机都采用小端字节序（little endian），相对重要的字节排在后面的内存地址，相对不重要字节排在前面的内存地址，所以就得到了上面的结果。</p>
<p>比如，一个占据四个字节的16进制数0x12345678，决定其大小的最重要的字节是“12”，最不重要的是“78”。小端字节序将最不重要的字节排在前面，储存顺序就是78563412；大端字节序则完全相反，将最重要的字节排在前面，储存顺序就是12345678。目前，所有个人电脑几乎都是小端字节序，所以类型化数组内部也采用小端字节序读写数据，或者更准确的说，按照本机操作系统设定的字节序读写数据。</p>
<p>这并不意味大端字节序不重要，事实上，很多网络设备和特定的操作系统采用的是大端字节序。这就带来一个严重的问题：如果一段数据是大端字节序，类型化数组将无法正确解析，因为它只能处理小端字节序！为了解决这个问题，JavaScript引入DataView对象，可以设定字节序，下文会详细介绍。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 假定某段buffer包含如下字节 [0x02, 0x01, 0x03, 0x07]</span></div><div class="line"><span class="comment">// 计算机采用小端字节序</span></div><div class="line"><span class="keyword">var</span> uInt16View = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 比较运算 </span></div><div class="line"><span class="keyword">if</span> (bufView[<span class="number">0</span>]===<span class="number">258</span>) &#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 赋值运算</span></div><div class="line">uInt16View[<span class="number">0</span>] = <span class="number">255</span>;    <span class="comment">// 字节变为[0xFF, 0x00, 0x03, 0x07]</span></div><div class="line">uInt16View[<span class="number">0</span>] = <span class="number">0xff05</span>; <span class="comment">// 字节变为[0x05, 0xFF, 0x03, 0x07]</span></div><div class="line">uInt16View[<span class="number">1</span>] = <span class="number">0x0210</span>; <span class="comment">// 字节变为[0x05, 0xFF, 0x10, 0x02]</span></div></pre></td></tr></table></figure>
<p>总之，与普通数组相比，类型化数组的最大优点就是可以直接操作内存，不需要数据类型转换，所以速度快得多。</p>
<p><strong>（2）buffer属性</strong></p>
<p>类型化数组的buffer属性，返回整段内存区域对应的ArrayBuffer对象。该属性为只读属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">64</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(a.buffer);</div></pre></td></tr></table></figure>
<p>上面代码的a对象和b对象，对应同一个ArrayBuffer对象，即同一段内存。</p>
<p><strong>（3）byteLength属性和byteOffset属性</strong></p>
<p>byteLength属性返回类型化数组占据的内存长度，单位为字节。byteOffset属性返回类型化数组从底层ArrayBuffer对象的哪个字节开始。这两个属性都是只读属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(b);</div><div class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(b, <span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(b, <span class="number">2</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line">v1.byteLength <span class="comment">// 8</span></div><div class="line">v2.byteLength <span class="comment">// 6</span></div><div class="line">v3.byteLength <span class="comment">// 4</span></div><div class="line"></div><div class="line">v1.byteOffset <span class="comment">// 0</span></div><div class="line">v2.byteOffset <span class="comment">// 2</span></div><div class="line">v3.byteOffset <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>注意将byteLength属性和length属性区分，前者是字节长度，后者是成员长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">8</span>);</div><div class="line"></div><div class="line">a.length <span class="comment">// 8</span></div><div class="line">a.byteLength <span class="comment">// 16</span></div></pre></td></tr></table></figure>
<p><strong>（4）set方法</strong></p>
<p>类型化数组的set方法用于复制数组，也就是将一段内容完全复制到另一段内存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">8</span>);</div><div class="line"></div><div class="line">b.set(a);</div></pre></td></tr></table></figure>
<p>上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">10</span>);</div><div class="line"></div><div class="line">b.set(a,<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。</p>
<p><strong>（5）subarray方法</strong></p>
<p>subarray方法是对于类型化数组的一部分，再建立一个新的视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> b = a.subarray(<span class="number">2</span>,<span class="number">3</span>);</div><div class="line"></div><div class="line">a.byteLength <span class="comment">// 16</span></div><div class="line">b.byteLength <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>subarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。</p>
<p><strong>（6）ArrayBuffer与字符串的互相转换</strong></p>
<p>ArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// ArrayBuffer转为字符串，参数为ArrayBuffer对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ab2str</span>(<span class="params">buf</span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode.apply(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buf));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 字符串转为ArrayBuffer对象，参数为字符串</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2ab</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(str.length*<span class="number">2</span>); <span class="comment">// 每个字符占用2个字节</span></div><div class="line">    <span class="keyword">var</span> bufView = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buf);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, strLen=str.length; i&lt;strLen; i++) &#123;</div><div class="line">         bufView[i] = str.charCodeAt(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="复合视图"><a href="#复合视图" class="headerlink" title="复合视图"></a>复合视图</h3><p>由于视图的构造函数可以指定起始位置和长度，所以在同一段内存之中，可以依次存放不同类型的数据，这叫做“复合视图”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">24</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> idView = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(buffer, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> usernameView = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buffer, <span class="number">4</span>, <span class="number">16</span>);</div><div class="line"><span class="keyword">var</span> amountDueView = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(buffer, <span class="number">20</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>上面代码将一个24字节长度的ArrayBuffer对象，分成三个部分：</p>
<ul>
<li>字节0到字节3：1个32位无符号整数</li>
<li>字节4到字节19：16个8位整数</li>
<li>字节20到字节23：1个32位浮点数</li>
</ul>
<p>这种数据结构可以用如下的C语言描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">struct</span> someStruct &#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> id;</div><div class="line">  <span class="keyword">char</span> username[<span class="number">16</span>];</div><div class="line">  <span class="keyword">float</span> amountDue;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="DataView视图"><a href="#DataView视图" class="headerlink" title="DataView视图"></a>DataView视图</h2><p>如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。</p>
<p>DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种类型化视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p>
<p>DataView本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">DataView</span>(<span class="built_in">ArrayBuffer</span> buffer [, 字节起始位置 [, 长度]]);</div></pre></td></tr></table></figure>
<p>下面是一个实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">24</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div></pre></td></tr></table></figure>
<p>DataView视图提供以下方法读取内存：</p>
<ul>
<li><strong>getInt8</strong>：读取1个字节，返回一个8位整数。</li>
<li><strong>getUint8</strong>：读取1个字节，返回一个无符号的8位整数。</li>
<li><strong>getInt16</strong>：读取2个字节，返回一个16位整数。</li>
<li><strong>getUint16</strong>：读取2个字节，返回一个无符号的16位整数。</li>
<li><strong>getInt32</strong>：读取4个字节，返回一个32位整数。</li>
<li><strong>getUint32</strong>：读取4个字节，返回一个无符号的32位整数。</li>
<li><strong>getFloat32</strong>：读取4个字节，返回一个32位浮点数。</li>
<li><strong>getFloat64</strong>：读取8个字节，返回一个64位浮点数。</li>
</ul>
<p>这一系列get方法的参数都是一个字节序号，表示从哪个字节开始读取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">24</span>);</div><div class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 从第1个字节读取一个8位无符号整数</span></div><div class="line"><span class="keyword">var</span> v1 = dv.getUint8(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 从第2个字节读取一个16位无符号整数</span></div><div class="line"><span class="keyword">var</span> v2 = dv.getUint16(<span class="number">1</span>); </div><div class="line"></div><div class="line"><span class="comment">// 从第4个字节读取一个16位无符号整数</span></div><div class="line"><span class="keyword">var</span> v3 = dv.getUint16(<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。</p>
<p>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 小端字节序</span></div><div class="line"><span class="keyword">var</span> v1 = dv.getUint16(<span class="number">1</span>, <span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="comment">// 大端字节序</span></div><div class="line"><span class="keyword">var</span> v2 = dv.getUint16(<span class="number">3</span>, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// 大端字节序</span></div><div class="line"><span class="keyword">var</span> v3 = dv.getUint16(<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>DataView视图提供以下方法写入内存：</p>
<ul>
<li><strong>setInt8</strong>：写入1个字节的8位整数。</li>
<li><strong>setUint8</strong>：写入1个字节的8位无符号整数。</li>
<li><strong>setInt16</strong>：写入2个字节的16位整数。</li>
<li><strong>setUint16</strong>：写入2个字节的16位无符号整数。</li>
<li><strong>setInt32</strong>：写入4个字节的32位整数。</li>
<li><strong>setUint32</strong>：写入4个字节的32位无符号整数。</li>
<li><strong>setFloat32</strong>：写入4个字节的32位浮点数。</li>
<li><strong>setFloat64</strong>：写入8个字节的64位浮点数。</li>
</ul>
<p>这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 在第1个字节，以大端字节序写入值为25的32位整数</span></div><div class="line">dv.setInt32(<span class="number">0</span>, <span class="number">25</span>, <span class="literal">false</span>); </div><div class="line"></div><div class="line"><span class="comment">// 在第5个字节，以大端字节序写入值为25的32位整数</span></div><div class="line">dv.setInt32(<span class="number">4</span>, <span class="number">25</span>); </div><div class="line"></div><div class="line"><span class="comment">// 在第9个字节，以小端字节序写入值为2.5的32位浮点数</span></div><div class="line">dv.setFloat32(<span class="number">8</span>, <span class="number">2.5</span>, <span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> littleEndian = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</div><div class="line">  <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer).setInt16(<span class="number">0</span>, <span class="number">256</span>, <span class="literal">true</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer)[<span class="number">0</span>] === <span class="number">256</span>;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>如果返回true，就是小端字节序；如果返回false，就是大端字节序。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>传统上，服务器通过Ajax操作只能返回文本数据。XMLHttpRequest 第二版允许服务器返回二进制数据，这时分成两种情况。如果明确知道返回的二进制数据类型，可以把返回类型（responseType）设为arraybuffer；如果不知道，就设为blob。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">xhr.responseType = <span class="string">'arraybuffer'</span>;</div></pre></td></tr></table></figure>
<p>如果知道传回来的是32位整数，可以像下面这样处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (req.readyState === <span class="number">4</span> ) &#123;</div><div class="line">    <span class="keyword">var</span> arrayResponse = xhr.response;</div><div class="line">    <span class="keyword">var</span> dataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(arrayResponse);</div><div class="line">    <span class="keyword">var</span> ints = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(dataView.byteLength / <span class="number">4</span>);</div><div class="line"></div><div class="line">    xhrDiv.style.backgroundColor = <span class="string">"#00FF00"</span>;</div><div class="line">    xhrDiv.innerText = <span class="string">"Array is "</span> + ints.length + <span class="string">"uints long"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>网页Canvas元素输出的二进制像素数据，就是类型化数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</div><div class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> imageData = ctx.getImageData(<span class="number">0</span>,<span class="number">0</span>, <span class="number">200</span>, <span class="number">100</span>);</div><div class="line"><span class="keyword">var</span> typedArray = imageData.data;</div></pre></td></tr></table></figure>
<p>需要注意的是，上面代码的typedArray虽然是一个类型化数组，但是它的视图类型是一种针对Canvas元素的专有类型Uint8ClampedArray。这个视图类型的特点，就是专门针对颜色，把每个字节解读为无符号的8位整数，即只能取值0～255，而且发生运算的时候自动过滤高位溢出。这为图像处理带来了巨大的方便。</p>
<p>举例来说，如果把像素的颜色值设为Uint8Array类型，那么乘以一个gamma值的时候，就必须这样计算：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">u8[i] = <span class="built_in">Math</span>.min(<span class="number">255</span>, <span class="built_in">Math</span>.max(<span class="number">0</span>, u8[i] * gamma));</div></pre></td></tr></table></figure>
<p>因为Uint8Array类型对于大于255的运算结果（比如0xFF+1），会自动变为0x00，所以图像处理必须要像上面这样算。这样做很麻烦，而且影响性能。如果将颜色值设为Uint8ClampedArray类型，计算就简化许多。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">pixels[i] *= gamma;</div></pre></td></tr></table></figure>
<p>Uint8ClampedArray类型确保将小于0的值设为0，将大于255的值设为255。注意，IE 10不支持该类型。</p>
<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>如果知道一个文件的二进制数据类型，也可以将这个文件读取为类型化数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">reader.readAsArrayBuffer(file);</div></pre></td></tr></table></figure>
<p>下面以处理bmp文件为例。假定file变量是一个指向bmp文件的文件对象，首先读取文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</div><div class="line">reader.addEventListener(<span class="string">"load"</span>, processimage, <span class="literal">false</span>); </div><div class="line">reader.readAsArrayBuffer(file);</div></pre></td></tr></table></figure>
<p>然后，定义处理图像的回调函数：先在二进制数据之上建立一个DataView视图，再建立一个bitmap对象，用于存放处理后的数据，最后将图像展示在canvas元素之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processimage</span>(<span class="params">e</span>) </span>&#123; </div><div class="line"> <span class="keyword">var</span> buffer = e.target.result; </div><div class="line"> <span class="keyword">var</span> datav = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer); </div><div class="line"> <span class="keyword">var</span> bitmap = &#123;&#125;;</div><div class="line"> <span class="comment">// 具体的处理步骤</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体处理图像数据时，先处理bmp的文件头。具体每个文件头的格式和定义，请参阅有关资料。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">bitmap.fileheader = &#123;&#125;; </div><div class="line">bitmap.fileheader.bfType = datav.getUint16(<span class="number">0</span>, <span class="literal">true</span>); </div><div class="line">bitmap.fileheader.bfSize = datav.getUint32(<span class="number">2</span>, <span class="literal">true</span>); </div><div class="line">bitmap.fileheader.bfReserved1 = datav.getUint16(<span class="number">6</span>, <span class="literal">true</span>); </div><div class="line">bitmap.fileheader.bfReserved2 = datav.getUint16(<span class="number">8</span>, <span class="literal">true</span>); </div><div class="line">bitmap.fileheader.bfOffBits = datav.getUint32(<span class="number">10</span>, <span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>接着处理图像元信息部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">bitmap.infoheader = &#123;&#125;;</div><div class="line">bitmap.infoheader.biSize = datav.getUint32(<span class="number">14</span>, <span class="literal">true</span>);</div><div class="line">bitmap.infoheader.biWidth = datav.getUint32(<span class="number">18</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biHeight = datav.getUint32(<span class="number">22</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biPlanes = datav.getUint16(<span class="number">26</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biBitCount = datav.getUint16(<span class="number">28</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biCompression = datav.getUint32(<span class="number">30</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biSizeImage = datav.getUint32(<span class="number">34</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biXPelsPerMeter = datav.getUint32(<span class="number">38</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biYPelsPerMeter = datav.getUint32(<span class="number">42</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biClrUsed = datav.getUint32(<span class="number">46</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biClrImportant = datav.getUint32(<span class="number">50</span>, <span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>最后处理图像本身的像素信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> start = bitmap.fileheader.bfOffBits;</div><div class="line">bitmap.pixels = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buffer, start);</div></pre></td></tr></table></figure>
<p>至此，图像文件的数据全部处理完成。下一步，可以根据需要，进行图像变形，或者转换格式，或者展示在Canvas网页元素之中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类型化数组是JavaScript操作二进制数据的一个接口。&lt;br&gt;这要从WebGL项目的诞生说起，所谓WebGL，就是指浏览器与显卡之间的通信接口，为了满足JavaScript与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。&lt;br&gt;比如，以文本格式传递一个32位整数，两端的JavaScript脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像C语言那样，直接操作字节，然后将4个字节的32位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。&lt;br&gt;类型化数组（Typed Array）就是在这种背景下诞生的。它很像C语言的数组，允许开发者以数组下标的形式，直接操作内存。有了类型化数组以后，JavaScript的二进制数据处理功能增强了很多，接口之间完全可以用二进制数据通信。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.houfeng.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 之 “Array对象”</title>
    <link href="http://blog.houfeng.net/2015/07/15/2014-12-15-javascript-array/"/>
    <id>http://blog.houfeng.net/2015/07/15/2014-12-15-javascript-array/</id>
    <published>2015-07-15T07:30:58.000Z</published>
    <updated>2016-08-27T03:34:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Array是JavaScript的内置对象，同时也是一个构造函数，可以用它生成新的数组。</p>
<p>作为构造函数时，Array可以接受参数，但是不同的参数，会使得Array产生不同的行为。</p>
<a id="more"></a>
<ul>
<li><p>无参数时，返回一个空数组。</p>
</li>
<li><p>单个参数时，如果该参数是正整数，则这个正整数表示新数组的长度；如果该参数是非正整数（比如字符串、布尔值、对象等），则该值是新数组的成员。</p>
</li>
<li><p>多个参数时，这些参数都是新数组的成员。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> a3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'abc'</span>);</div><div class="line"><span class="keyword">var</span> a4 = <span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>]);</div><div class="line"><span class="keyword">var</span> a5 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line"></div><div class="line">a1 <span class="comment">// []</span></div><div class="line">a2 <span class="comment">// [undefined × 1]</span></div><div class="line">a3 <span class="comment">// ['abc']</span></div><div class="line">a4 <span class="comment">// [Array[1]]</span></div><div class="line">a5 <span class="comment">// [1, 2]</span></div></pre></td></tr></table></figure>
<p>从上面代码可以看到，Array的构造函数行为很不一致。因此，不建议使用它生成新数组，直接使用数组的字面量是更好的方法。</p>
<h2 id="Array对象的静态方法"><a href="#Array对象的静态方法" class="headerlink" title="Array对象的静态方法"></a>Array对象的静态方法</h2><h3 id="isArray方法"><a href="#isArray方法" class="headerlink" title="isArray方法"></a>isArray方法</h3><p>Array.isArray方法用来判断一个值是否为数组。它可以弥补typeof运算符的不足。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> a <span class="comment">// "object"</span></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.isArray(a) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码表示，typeof运算符只能显示数组的类型是Object，而Array.isArray方法可以对数组返回true。</p>
<h2 id="Array实例的方法"><a href="#Array实例的方法" class="headerlink" title="Array实例的方法"></a>Array实例的方法</h2><p>以下这些Array实例对象的方法，都是数组实例才能使用。如果不想创建实例，只是想单纯调用这些方法，可以写成 [].method.call(调用对象，参数) 的形式，或者 Array.prototype.method.call(调用对象，参数)的形式。</p>
<h3 id="valueOf方法，toString方法"><a href="#valueOf方法，toString方法" class="headerlink" title="valueOf方法，toString方法"></a>valueOf方法，toString方法</h3><p>valueOf方法返回数组本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"></div><div class="line">a.valueOf()</div><div class="line"><span class="comment">// [1,2,3]</span></div></pre></td></tr></table></figure>
<p>toString 方法返回数组的字符串形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"></div><div class="line">a.toString()</div><div class="line"><span class="comment">// "1,2,3"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]];</div><div class="line"></div><div class="line">a.toString()</div><div class="line"><span class="comment">// "1,2,3,4,5,6"</span></div></pre></td></tr></table></figure>
<h3 id="push方法，pop方法"><a href="#push方法，pop方法" class="headerlink" title="push方法，pop方法"></a>push方法，pop方法</h3><p>push方法用于在数组的末端添加一个或多个元素，并返回添加后的数组的长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"></div><div class="line">a.push(<span class="number">1</span>) <span class="comment">// 1</span></div><div class="line">a.push(<span class="string">"a"</span>) <span class="comment">// 2</span></div><div class="line">a.push(<span class="literal">true</span>, &#123;&#125;) <span class="comment">// 4</span></div><div class="line">a <span class="comment">// [1, "a", true, &#123;&#125;]</span></div></pre></td></tr></table></figure>
<p>上面代码使用push方法，先后往数组中添加了四个成员。</p>
<p>如果需要合并两个数组，可以这样写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.push.apply(a, b)</div><div class="line"><span class="comment">// 或者</span></div><div class="line">a.push.apply(a,b)</div><div class="line"></div><div class="line"><span class="comment">// 上面两种写法等同于</span></div><div class="line">a.push(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</div><div class="line"></div><div class="line">a</div><div class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></div></pre></td></tr></table></figure>
<p>push方法还可以用于向对象添加元素，添加后的对象变成“类似数组的”对象，即新加入元素的键对应数组的索引，并且对象有一个length属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123; a: <span class="number">1</span> &#125;;</div><div class="line"></div><div class="line">[].push.call(a, <span class="number">2</span>);</div><div class="line">a</div><div class="line"><span class="comment">// &#123;a:1, 0:2, length: 1&#125;</span></div><div class="line"></div><div class="line">[].push.call(a, [<span class="number">3</span>]);</div><div class="line">a</div><div class="line"><span class="comment">// &#123;a:1, 0:2, 1:[3], length: 2&#125;</span></div></pre></td></tr></table></figure>
<p>pop方法用于删除数组的最后一个元素，并返回该元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"></div><div class="line">a.pop() <span class="comment">// 'c'</span></div><div class="line">a <span class="comment">// ['a', 'b']</span></div></pre></td></tr></table></figure>
<p>对空数组使用pop方法，不会报错，而是返回undefined。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[].pop() <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<h3 id="join方法，concat方法"><a href="#join方法，concat方法" class="headerlink" title="join方法，concat方法"></a>join方法，concat方法</h3><p>join方法以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"></div><div class="line">a.join() <span class="comment">// "1,2,3,4"</span></div><div class="line">a.join(<span class="string">''</span>) <span class="comment">// '1234'</span></div><div class="line">a.join(<span class="string">"|"</span>) <span class="comment">// "1|2|3|4"</span></div></pre></td></tr></table></figure>
<p>通过函数的call方法，join方法（即Array.prototype.join）也可以用于字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.join.call(<span class="string">'hello'</span>, <span class="string">'-'</span>)</div><div class="line"><span class="comment">// "h-e-l-l-o"</span></div></pre></td></tr></table></figure>
<p>concat方法将新数组的成员，添加到原数组的尾部，然后返回一个新数组，常用于连接多个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="string">"hello"</span>].concat([<span class="string">"world"</span>])</div><div class="line"><span class="comment">// ["hello", "world"]</span></div><div class="line"></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].concat(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</div><div class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></div></pre></td></tr></table></figure>
<p>上面代码表明，concat方法的参数可以是一个或多个数组，以及原始类型的值。</p>
<p>如果不提供参数，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是如果数组成员包括复合类型的值（比如对象），则新数组拷贝的是该值的引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;a:<span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">var</span> oldArray = [o];</div><div class="line"></div><div class="line"><span class="keyword">var</span> newArray = oldArray.concat();</div><div class="line"></div><div class="line">o.a = <span class="number">2</span>;</div><div class="line">newArray[<span class="number">0</span>].a <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>上面代码中，原数组包含一个对象，concat方法生成的新数组包含这个对象的引用。所以，改变原对象以后，新数组跟着改变。事实上，只要原数组的成员中包含对象，concat方法不管有没有参数，总是返回该对象的引用。</p>
<p>concat方法也可以用于将对象合并为数组，但是必须借助call方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[].concat.call(&#123; a: <span class="number">1</span> &#125;, [<span class="number">2</span>])</div><div class="line"><span class="comment">// [&#123;a:1&#125;, 2]</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line">[<span class="number">2</span>].concat(&#123;a:<span class="number">1</span>&#125;)</div></pre></td></tr></table></figure>
<h3 id="shift方法，unshift方法"><a href="#shift方法，unshift方法" class="headerlink" title="shift方法，unshift方法"></a>shift方法，unshift方法</h3><p>shift方法用于删除数组的第一个元素，并返回该元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"></div><div class="line">a.shift() <span class="comment">// 'a'</span></div><div class="line">a <span class="comment">// ['b', 'c']</span></div></pre></td></tr></table></figure>
<p>shift方法可以遍历并清空一个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> item;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (item = list.shift()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(item);</div><div class="line">&#125;</div><div class="line"></div><div class="line">list <span class="comment">// []</span></div></pre></td></tr></table></figure>
<p>unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"></div><div class="line">a.unshift(<span class="string">'x'</span>); <span class="comment">// 4</span></div><div class="line">a <span class="comment">// ['x', 'a', 'b', 'c']</span></div></pre></td></tr></table></figure>
<h3 id="reverse方法"><a href="#reverse方法" class="headerlink" title="reverse方法"></a>reverse方法</h3><p>reverse方法用于颠倒数组中元素的顺序，使用这个方法以后，返回改变后的原数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"></div><div class="line">a.reverse() <span class="comment">// ["c", "b", "a"] </span></div><div class="line">a <span class="comment">// ["c", "b", "a"]</span></div></pre></td></tr></table></figure>
<h3 id="slice方法"><a href="#slice方法" class="headerlink" title="slice方法"></a>slice方法</h3><p>slice方法返回指定位置的数组成员组成的新数组，原数组不变。它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>];</div><div class="line"></div><div class="line">a.slice(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// ["b"]</span></div><div class="line">a.slice(<span class="number">1</span>) <span class="comment">// ["b", "c"]</span></div><div class="line">a.slice(<span class="number">0</span>) <span class="comment">// ["a","b","c"]</span></div><div class="line">a.slice(<span class="number">-2</span>) <span class="comment">// ["b", "c"]</span></div><div class="line">a.slice(<span class="number">4</span>) <span class="comment">// []</span></div><div class="line">a.slice(<span class="number">2</span>, <span class="number">6</span>) <span class="comment">// ["c"]</span></div><div class="line">a.slice(<span class="number">2</span>, <span class="number">1</span>) <span class="comment">// []</span></div></pre></td></tr></table></figure>
<p>上面代码表示，如果slice方法的参数是负数，则从尾部开始选择的成员个数；如果参数值大于数组成员的个数，或者第二个参数小于第一个参数，则返回空数组。</p>
<p>slice方法的一个重要应用，是将类似数组的对象转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.slice.call(&#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, length: <span class="number">2</span> &#125;)</div><div class="line"><span class="comment">// ['a', 'b']</span></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">"div"</span>));</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div></pre></td></tr></table></figure>
<p>上面代码的参数都不是数组，但是通过call方法，在它们上面调用slice方法，就可以把它们转为真正的数组。</p>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>splice方法用于删除元素，并可以在被删除的位置添加入新的数组元素。它的返回值是被删除的元素。需要特别注意的是，该方法会改变原数组。</p>
<p>splice的第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>];</div><div class="line"></div><div class="line">a.splice(<span class="number">4</span>,<span class="number">2</span>)</div><div class="line"><span class="comment">// ["e", "f"]</span></div><div class="line"></div><div class="line">a</div><div class="line"><span class="comment">// ["a", "b", "c", "d"]</span></div></pre></td></tr></table></figure>
<p>上面代码从原数组位置4开始，删除了两个数组成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>];</div><div class="line"></div><div class="line">a.splice(<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"><span class="comment">// ["e", "f"]</span></div><div class="line"></div><div class="line">a</div><div class="line"><span class="comment">// ["a", "b", "c", "d", 1, 2]</span></div></pre></td></tr></table></figure>
<p>上面代码除了删除成员，还插入了两个新成员。</p>
<p>如果只是单纯地插入元素，splice方法的第二个参数可以设为0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>];</div><div class="line"></div><div class="line">a.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>)</div><div class="line"><span class="comment">// []</span></div><div class="line"></div><div class="line">a</div><div class="line"><span class="comment">// [1, 2, 1, 1]</span></div></pre></td></tr></table></figure>
<p>如果只提供第一个参数，则实际上等同于将原数组在指定位置拆分成两个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"></div><div class="line">a.splice(<span class="number">2</span>)</div><div class="line"><span class="comment">// [3, 4]</span></div><div class="line"></div><div class="line">a</div><div class="line"><span class="comment">// [1, 2]</span></div></pre></td></tr></table></figure>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>sort方法对数组元素进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="string">"d"</span>,<span class="string">"c"</span>,<span class="string">"b"</span>,<span class="string">"a"</span>].sort()</div><div class="line"><span class="comment">// ["a", "b", "c", "d"]</span></div><div class="line"></div><div class="line">[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>].sort()</div><div class="line"><span class="comment">// [1, 2, 3, 4]</span></div><div class="line"></div><div class="line">[<span class="number">11</span>,<span class="number">101</span>].sort()</div><div class="line"><span class="comment">// [101, 11]</span></div><div class="line"></div><div class="line">[<span class="number">10111</span>,<span class="number">1101</span>,<span class="number">111</span>].sort()</div><div class="line"><span class="comment">// [10111, 1101, 111]</span></div></pre></td></tr></table></figure>
<p>上面代码的最后两个例子，需要特殊注意。sort方法不是按照大小排序，而是按照对应字符串的字典顺序排序，所以101排在11的前面。</p>
<p>如果想让sort方法按照大小排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">10111</span>,<span class="number">1101</span>,<span class="number">111</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a-b;</div><div class="line">&#125;)</div><div class="line"><span class="comment">// [111, 1101, 10111]</span></div><div class="line"></div><div class="line">[</div><div class="line">  &#123; name: <span class="string">"张三"</span>, age: <span class="number">30</span> &#125;,</div><div class="line">  &#123; name: <span class="string">"李四"</span>, age: <span class="number">24</span> &#125;,</div><div class="line">  &#123; name: <span class="string">"王五"</span>, age: <span class="number">28</span>  &#125;</div><div class="line">].sort(<span class="function"><span class="keyword">function</span>(<span class="params">o1, o2</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> o1.age - o2.age;</div><div class="line">&#125;)</div><div class="line"><span class="comment">// [</span></div><div class="line"><span class="comment">//   &#123; name: "李四", age: 24 &#125;,</span></div><div class="line"><span class="comment">//   &#123; name: "王五", age: 28  &#125;,</span></div><div class="line"><span class="comment">//   &#123; name: "张三", age: 30 &#125;</span></div><div class="line"><span class="comment">// ]</span></div></pre></td></tr></table></figure>
<h2 id="ECMAScript-5-新加入的数组方法"><a href="#ECMAScript-5-新加入的数组方法" class="headerlink" title="ECMAScript 5 新加入的数组方法"></a>ECMAScript 5 新加入的数组方法</h2><p>ECMAScript 5新增了9个数组实例的方法，分别是map、forEach、filter、every、some、reduce、reduceRight、indexOf和lastIndexOf。其中，前7个与函数式（functional）操作有关。</p>
<p>这些方法可以在数组上使用，也可以在字符串和类似数组的对象上使用，这是它们不同于传统数组方法的一个地方。</p>
<p>在用法上，这些方法的参数是一个函数，这个作为参数的函数本身又接受三个参数：数组的当前元素elem、该元素的位置index和整个数组arr（详见下面的实例）。另外，上下文对象（context）可以作为第二个参数，传入forEach(), every(), some(), filter(), map()方法，用来绑定函数运行时的上下文。</p>
<p>对于不支持这些方法的老式浏览器（主要是IE 8及以下版本），可以使用函数库<a href="https://github.com/kriskowal/es5-shim" target="_blank" rel="external">es5-shim</a>，或者<a href="http://underscorejs.org/#filter" target="_blank" rel="external">Underscore</a>和<a href="http://lodash.com/docs#filter" target="_blank" rel="external">Lo-Dash</a>。</p>
<h3 id="map方法，forEach方法"><a href="#map方法，forEach方法" class="headerlink" title="map方法，forEach方法"></a>map方法，forEach方法</h3><p>map方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line">numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="keyword">return</span> n+<span class="number">1</span> &#125;);</div><div class="line"><span class="comment">// [2, 3, 4]</span></div><div class="line"></div><div class="line">numbers</div><div class="line"><span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
<p>上面代码中，原数组的成员都加上1，组成一个新数组返回，原数组没有变化。</p>
<p>只要数组的成员可以被索引到，map方法就不会跳过它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="keyword">return</span> n+<span class="number">1</span> &#125;;</div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>].map(f) <span class="comment">// [2, NaN, 3]</span></div><div class="line">[<span class="number">1</span>, <span class="literal">null</span>, <span class="number">2</span>].map(f) <span class="comment">// [2, 1, 3]</span></div><div class="line">[<span class="number">1</span>, , <span class="number">2</span>].map(f) <span class="comment">// [2, undefined, 3]</span></div></pre></td></tr></table></figure>
<p>上面代码中，数组的成员分别是undefined、null和空位，map方法都不会跳过它们。</p>
<p>map方法的回调函数依次接受三个参数，分别是当前的数组成员、当前成员的位置和数组本身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">elem, index, arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> elem * elem;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// [1, 4, 9]</span></div></pre></td></tr></table></figure>
<p>有时，我们需要对字符串的每个字符进行遍历。这时可以通过函数的call方法，将map方法用于字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> upper = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x.toUpperCase() &#125;;</div><div class="line"></div><div class="line">[].map.call(<span class="string">'abc'</span>, upper)</div><div class="line"><span class="comment">// [ 'A', 'B', 'C' ]</span></div><div class="line"></div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="string">'abc'</span>.split(<span class="string">''</span>).map(upper)</div><div class="line"><span class="comment">// [ 'A', 'B', 'C' ]</span></div></pre></td></tr></table></figure>
<p>其他类似数组的对象（比如querySelectorAll方法返回DOM节点集合），也可以用上面的方法遍历。</p>
<p>map方法还可以接受第二个参数，表示回调函数执行时this所指向的对象。</p>
<p>数组实例的forEach方法与map方法很相似，也是遍历数组的所有成员，执行某种操作，但是forEach方法没有返回值。如果需要有返回值，一般使用map方法，如果只是单纯操作数据，一般使用forEach方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">element, index, array</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'['</span> + index + <span class="string">'] = '</span> + element);</div><div class="line">&#125;</div><div class="line"></div><div class="line">[<span class="number">2</span>, <span class="number">5</span>, , <span class="number">9</span>].forEach(log);</div><div class="line"><span class="comment">// [0] = 2</span></div><div class="line"><span class="comment">// [1] = 5</span></div><div class="line"><span class="comment">// [3] = 9</span></div></pre></td></tr></table></figure>
<p>从上面代码可以看到，forEach方法和map方法的参数格式是一样的，第一个参数都是一个函数。该函数接受三个参数，分别是当前元素、当前元素的位置（从0开始）、整个数组。</p>
<p>forEach方法会跳过数组的空位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="built_in">console</span>.log(n + <span class="number">1</span>) &#125;;</div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>].forEach(log)</div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// NaN</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="literal">null</span>, <span class="number">2</span>].forEach(log)</div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"></div><div class="line">[<span class="number">1</span>, , <span class="number">2</span>].map(f)</div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>上面代码中，forEach方法不会跳过undefined和null，但会跳过空位。</p>
<p>forEach方法也可以接受第二个参数，用来绑定回调函数的this关键字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> out = [];</div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">elem, index, arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.push(elem * elem);</div><div class="line">&#125;, out);</div><div class="line"></div><div class="line">out <span class="comment">// [1, 4, 9]</span></div></pre></td></tr></table></figure>
<p>上面代码表示，如果提供一个数组作为第二个参数，则函数内部的this关键字就指向这个数组。</p>
<h3 id="filter方法"><a href="#filter方法" class="headerlink" title="filter方法"></a>filter方法</h3><p>filter方法依次对所有数组成员调用一个测试函数，返回结果为true的成员组成一个新数组返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].filter(<span class="function"><span class="keyword">function</span> (<span class="params">elem</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> (elem &gt; <span class="number">3</span>);</div><div class="line">&#125;)</div><div class="line"><span class="comment">// [4,5]</span></div></pre></td></tr></table></figure>
<p>上面代码将大于3的原数组成员，作为一个新数组返回。</p>
<p>filter方法的测试函数可以接受三个参数，第一个参数是当前数组成员的值，这是必需的，后两个参数是可选的，分别是当前数组成员的位置和整个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem, index, arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> index % <span class="number">2</span> === <span class="number">0</span>;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// [1, 3, 5]</span></div></pre></td></tr></table></figure>
<p>上面代码返回原数组偶数位置的成员组成的新数组。</p>
<p>filter方法还可以接受第二个参数，指定测试函数所在的上下文对象（即this对象）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> Obj = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.MAX = <span class="number">3</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myFilter = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (item &gt; <span class="keyword">this</span>.MAX) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>];</div><div class="line">arr.filter(myFilter, <span class="keyword">new</span> Obj())</div><div class="line"><span class="comment">// [8, 4, 9]</span></div></pre></td></tr></table></figure>
<p>上面代码中，测试函数myFilter内部有this对象，它可以被filter方法的第二个参数绑定。</p>
<h3 id="some方法，every方法"><a href="#some方法，every方法" class="headerlink" title="some方法，every方法"></a>some方法，every方法</h3><p>这两个方法类似“断言”（assert），用来判断数组成员是否符合某种条件。</p>
<p>some方法对所有元素调用一个测试函数，只要有一个元素通过该测试，就返回true，否则返回false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].some(<span class="function"><span class="keyword">function</span>(<span class="params">elem, index, arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> elem &gt;= <span class="number">3</span>;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 返回true</span></div></pre></td></tr></table></figure>
<p>上面代码表示，如果存在大于等于3的数组成员，就返回true。</p>
<p>every方法对所有元素调用一个测试函数，只有所有元素通过该测试，才返回true，否则返回false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].every(<span class="function"><span class="keyword">function</span>(<span class="params">elem, index, arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> elem &gt;= <span class="number">3</span>;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 返回false</span></div></pre></td></tr></table></figure>
<p>上面代码表示，只有所有数组成员大于等于3，才返回true。</p>
<p>从上面的代码可以看到，some和every的使用方法与map和forEach是一致的，参数完全一模一样。也就是说，它们也可以使用第二个参数，用来绑定函数中的this关键字。</p>
<h3 id="reduce方法，reduceRight方法"><a href="#reduce方法，reduceRight方法" class="headerlink" title="reduce方法，reduceRight方法"></a>reduce方法，reduceRight方法</h3><p>reduce方法和reduceRight方法的作用，是依次处理数组的每个元素，最终累计为一个值。这两个方法的差别在于，reduce对数组元素的处理顺序是从左到右（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他地方完全一样。</p>
<p>reduce方法的第一个参数是一个处理函数。该函数接受四个参数，分别是：</p>
<ol>
<li>用来累计的变量（即当前状态），默认值为0</li>
<li>数组的当前元素</li>
<li>当前元素在数组中的序号（从0开始）</li>
<li>原数组</li>
</ol>
<p>这四个参数之中，只有前两个是必须的，后两个则是可选的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> x+y;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 15</span></div></pre></td></tr></table></figure>
<p>上面代码的参数x表示累计变量，默认为0，y则是数组的当前元素。reduce方法依次将每个数组元素加入x，最终返回它们的总和15。</p>
<p>利用reduce方法，可以写一个数组求和的sum方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">partial, value</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> partial + value;</div><div class="line">    &#125;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>].sum()</div><div class="line"><span class="comment">// 28</span></div></pre></td></tr></table></figure>
<p>如果要对累计变量指定初值，可以把它放在reduce方法的第二个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> x+y;</div><div class="line">&#125;, <span class="number">10</span>);</div><div class="line"><span class="comment">// 25</span></div></pre></td></tr></table></figure>
<p>上面代码指定参数x的初值为10，所以数组元素从10开始累加，最终结果为25。</p>
<p>由于reduce方法依次处理每个元素，所以实际上还可以用它来搜索某个元素。比如，下面代码是找出长度最长的数组元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLongest</span>(<span class="params">entries</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> entries.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">longest, entry</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> entry.length &gt; longest.length ? entry : longest;</div><div class="line">  &#125;, <span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf 和 lastIndexOf"></a>indexOf 和 lastIndexOf</h3><p>ECMAScript 5新增的9个方法之中，有2个与函数式编程无关，分别是indexOf和lastIndexOf。</p>
<p>indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</div><div class="line"></div><div class="line">a.indexOf(<span class="string">'b'</span>)</div><div class="line"><span class="comment">// 1</span></div><div class="line"></div><div class="line">a.indexOf(<span class="string">'y'</span>)</div><div class="line"><span class="comment">// -1</span></div></pre></td></tr></table></figure>
<p>indexOf方法还可以接受第二个参数，表示搜索的开始位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>].indexOf(<span class="string">'a'</span>, <span class="number">1</span>)</div><div class="line"><span class="comment">// -1</span></div></pre></td></tr></table></figure>
<p>上面代码从位置1开始搜索字符a，结果为-1，表示没有搜索到。</p>
<p>lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>];</div><div class="line"></div><div class="line">a.lastIndexOf(<span class="number">2</span>)</div><div class="line"><span class="comment">// 3</span></div><div class="line"></div><div class="line">a.lastIndexOf(<span class="number">7</span>)</div><div class="line"><span class="comment">// -1</span></div></pre></td></tr></table></figure>
<p>注意，如果数组中包含NaN，这两个方法不适用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></div><div class="line">[<span class="literal">NaN</span>].lastIndexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></div></pre></td></tr></table></figure>
<p>这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。</p>
<h3 id="链式使用"><a href="#链式使用" class="headerlink" title="链式使用"></a>链式使用</h3><p>上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> users = [&#123;name:<span class="string">"tom"</span>, email:<span class="string">"tom@example.com"</span>&#125;,</div><div class="line">			 &#123;name:<span class="string">"peter"</span>, email:<span class="string">"peter@example.com"</span>&#125;];</div><div class="line"></div><div class="line">users</div><div class="line">.map(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>)</span>&#123; <span class="keyword">return</span> user.email; &#125;)</div><div class="line">.filter(<span class="function"><span class="keyword">function</span> (<span class="params">email</span>) </span>&#123; <span class="keyword">return</span> <span class="regexp">/^t/</span>.test(email); &#125;)</div><div class="line">.forEach(alert);</div><div class="line"><span class="comment">// 弹出tom@example.com</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Array是JavaScript的内置对象，同时也是一个构造函数，可以用它生成新的数组。&lt;/p&gt;
&lt;p&gt;作为构造函数时，Array可以接受参数，但是不同的参数，会使得Array产生不同的行为。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.houfeng.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 之 “Math对象”</title>
    <link href="http://blog.houfeng.net/2015/07/15/2014-07-15-javascript-math/"/>
    <id>http://blog.houfeng.net/2015/07/15/2014-07-15-javascript-math/</id>
    <published>2015-07-15T07:29:16.000Z</published>
    <updated>2016-08-27T03:34:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Math对象是JavaScript的内置对象，提供一系列数学常数和数学方法。</p>
<p>该对象不是构造函数，所以不能生成实例，所有的属性和方法都必须在Math对象上调用。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Math</span>()</div><div class="line"><span class="comment">// TypeError: object is not a function</span></div></pre></td></tr></table></figure>
<p>上面代码表示，Math不能当作构造函数用。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>Math对象提供以下一些只读的数学常数。</p>
<ul>
<li>E：常数e。</li>
<li>LN2：2的自然对数。</li>
<li>LN10：10的自然对数。</li>
<li>LOG2E：以2为底的e的对数。</li>
<li>LOG10E：以10为底的e的对数。</li>
<li>PI：常数Pi。</li>
<li>SQRT1_2：0.5的平方根。</li>
<li>SQRT2：2的平方根。</li>
</ul>
<p>这些常数的值如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.E <span class="comment">// 2.718281828459045</span></div><div class="line"><span class="built_in">Math</span>.LN2 <span class="comment">// 0.6931471805599453</span></div><div class="line"><span class="built_in">Math</span>.LN10 <span class="comment">// 2.302585092994046</span></div><div class="line"><span class="built_in">Math</span>.LOG2E <span class="comment">// 1.4426950408889634</span></div><div class="line"><span class="built_in">Math</span>.LOG10E <span class="comment">// 0.4342944819032518</span></div><div class="line"><span class="built_in">Math</span>.PI <span class="comment">// 3.141592653589793</span></div><div class="line"><span class="built_in">Math</span>.SQRT1_2 <span class="comment">// 0.7071067811865476</span></div><div class="line"><span class="built_in">Math</span>.SQRT2 <span class="comment">// 1.4142135623730951</span></div></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Math对象提供以下一些数学方法。</p>
<h3 id="round方法"><a href="#round方法" class="headerlink" title="round方法"></a>round方法</h3><p>round方法用于四舍五入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.round(<span class="number">0.1</span>) <span class="comment">// 0</span></div><div class="line"><span class="built_in">Math</span>.round(<span class="number">0.5</span>) <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>它对于负值的运算结果与正值略有不同，主要体现在对.5的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.round(<span class="number">-1.1</span>) <span class="comment">// -1</span></div><div class="line"><span class="built_in">Math</span>.round(<span class="number">-1.5</span>) <span class="comment">// -1</span></div></pre></td></tr></table></figure>
<h3 id="abs方法，max方法，min方法"><a href="#abs方法，max方法，min方法" class="headerlink" title="abs方法，max方法，min方法"></a>abs方法，max方法，min方法</h3><p>abs方法返回参数值的绝对值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.abs(<span class="number">1</span>) <span class="comment">// 1</span></div><div class="line"><span class="built_in">Math</span>.abs(<span class="number">-1</span>) <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>max方法返回最大的参数，min方法返回最小的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.max(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">5</span>) <span class="comment">// 5</span></div><div class="line"><span class="built_in">Math</span>.min(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">5</span>) <span class="comment">// -1</span></div></pre></td></tr></table></figure>
<h3 id="floor方法，ceil方法"><a href="#floor方法，ceil方法" class="headerlink" title="floor方法，ceil方法"></a>floor方法，ceil方法</h3><p>floor方法返回小于参数值的最大整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.floor(<span class="number">3.2</span>) <span class="comment">// 3</span></div><div class="line"><span class="built_in">Math</span>.floor(<span class="number">-3.2</span>) <span class="comment">// -4</span></div></pre></td></tr></table></figure>
<p>ceil方法返回大于参数值的最小整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.ceil(<span class="number">3.2</span>) <span class="comment">// 4</span></div><div class="line"><span class="built_in">Math</span>.ceil(<span class="number">-3.2</span>) <span class="comment">// -3</span></div></pre></td></tr></table></figure>
<h3 id="pow方法，sqrt方法"><a href="#pow方法，sqrt方法" class="headerlink" title="pow方法，sqrt方法"></a>pow方法，sqrt方法</h3><p>power方法返回以第一个参数为底数、第二个参数为幂的指数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>) <span class="comment">// 4</span></div><div class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 8</span></div></pre></td></tr></table></figure>
<p>sqrt方法法返回参数值的平方根。如果参数是一个负值，则返回NaN。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.sqrt(<span class="number">4</span>) <span class="comment">// 2</span></div><div class="line"><span class="built_in">Math</span>.sqrt(<span class="number">-4</span>) <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
<h3 id="log方法，exp方法"><a href="#log方法，exp方法" class="headerlink" title="log方法，exp方法"></a>log方法，exp方法</h3><p>log方法返回以e为底的自然对数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.log(<span class="built_in">Math</span>.E) <span class="comment">// 1</span></div><div class="line"><span class="built_in">Math</span>.log(<span class="number">10</span>) <span class="comment">// 2.302585092994046</span></div></pre></td></tr></table></figure>
<p>求以10为底的对数，可以除以Math.LN10；求以2为底的对数，可以除以Math.LN2。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.log(<span class="number">100</span>)/<span class="built_in">Math</span>.LN10 <span class="comment">// 2</span></div><div class="line"><span class="built_in">Math</span>.log(<span class="number">8</span>)/<span class="built_in">Math</span>.LN2 <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>exp方法返回常数e的参数次方。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.exp(<span class="number">1</span>) <span class="comment">// 2.718281828459045</span></div><div class="line"><span class="built_in">Math</span>.exp(<span class="number">3</span>) <span class="comment">// 20.085536923187668</span></div></pre></td></tr></table></figure>
<h3 id="random方法"><a href="#random方法" class="headerlink" title="random方法"></a>random方法</h3><p>该方法返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.random() <span class="comment">// 0.7151307314634323</span></div><div class="line"></div><div class="line"><span class="comment">// 返回给定范围内的随机数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomArbitrary</span>(<span class="params">min, max</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() * (max - min) + min;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 返回给定范围内的随机整数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomInt</span>(<span class="params">min, max</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h3><p>sin方法返回参数的正弦，cos方法返回参数的余弦，tan方法返回参数的正切。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.sin(<span class="number">0</span>) <span class="comment">// 0</span></div><div class="line"><span class="built_in">Math</span>.cos(<span class="number">0</span>) <span class="comment">// 1</span></div><div class="line"><span class="built_in">Math</span>.tan(<span class="number">0</span>) <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p>asin方法返回参数的反正弦，acos方法返回参数的反余弦，atan方法返回参数的反正切。这个三个方法的返回值都是弧度值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.asin(<span class="number">1</span>) <span class="comment">// 1.5707963267948966</span></div><div class="line"><span class="built_in">Math</span>.acos(<span class="number">1</span>) <span class="comment">// 0</span></div><div class="line"><span class="built_in">Math</span>.atan(<span class="number">1</span>) <span class="comment">// 0.7853981633974483</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Math对象是JavaScript的内置对象，提供一系列数学常数和数学方法。&lt;/p&gt;
&lt;p&gt;该对象不是构造函数，所以不能生成实例，所有的属性和方法都必须在Math对象上调用。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.houfeng.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 之 “包装器对象”</title>
    <link href="http://blog.houfeng.net/2015/07/15/2015-03-15-javascript-wraper/"/>
    <id>http://blog.houfeng.net/2015/07/15/2015-03-15-javascript-wraper/</id>
    <published>2015-07-15T07:24:14.000Z</published>
    <updated>2016-08-27T03:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在JavaScript中，“一切皆对象”，数组和函数本质上都是对象，就连三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。</p>
<p>所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</div><div class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</div><div class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>上面代码根据原始类型的值，生成了三个对象，与原始值的类型不同。这用typeof运算符就可以看出来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typeof</span> v1 <span class="comment">// "object"</span></div><div class="line"><span class="keyword">typeof</span> v2 <span class="comment">// "object"</span></div><div class="line"><span class="keyword">typeof</span> v3 <span class="comment">// "object"</span></div><div class="line"></div><div class="line">v1 === <span class="number">123</span> <span class="comment">// false</span></div><div class="line">v2 === <span class="string">"abc"</span> <span class="comment">// false</span></div><div class="line">v3 === <span class="literal">true</span> <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>JavaScript设计包装对象的最大目的，首先是使得JavaScript的“对象”涵盖所有的值。其次，使得原始类型的值可以方便地调用特定方法。</p>
<h3 id="包装对象的构造函数"><a href="#包装对象的构造函数" class="headerlink" title="包装对象的构造函数"></a>包装对象的构造函数</h3><p>Number、String和Boolean这三个原生对象，既可以当作构造函数使用（即加上new关键字，生成包装对象实例），也可以当作工具方法使用（即不加new关键字，直接调用），这相当于生成实例后再调用valueOf方法，常常用于将任意类型的值转为某种原始类型的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Number</span>(<span class="number">123</span>) <span class="comment">// 123</span></div><div class="line"></div><div class="line"><span class="built_in">String</span>(<span class="string">"abc"</span>) <span class="comment">// "abc"</span></div><div class="line"></div><div class="line"><span class="built_in">Boolean</span>(<span class="literal">true</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>工具方法的详细介绍参见第二章的《数据类型转换》一节。</p>
<h3 id="包装对象实例的方法"><a href="#包装对象实例的方法" class="headerlink" title="包装对象实例的方法"></a>包装对象实例的方法</h3><p>包装对象实例可以使用Object对象提供的原生方法，主要是 valueOf 方法和 toString 方法。</p>
<p><strong>（1）valueOf方法</strong></p>
<p>valueOf方法返回包装对象实例对应的原始类型的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>).valueOf()</div><div class="line"><span class="comment">// 123</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>).valueOf()</div><div class="line"><span class="comment">// "abc"</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"true"</span>).valueOf()</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><strong>（2）toString方法</strong></p>
<p>toString方法返回该实例对应的原始类型值的字符串形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>).toString()</div><div class="line"><span class="comment">// "123"</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>).toString()</div><div class="line"><span class="comment">// "abc"</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"true"</span>).toString()</div><div class="line"><span class="comment">// "true"</span></div></pre></td></tr></table></figure>
<h3 id="原始类型的自动转换"><a href="#原始类型的自动转换" class="headerlink" title="原始类型的自动转换"></a>原始类型的自动转换</h3><p>原始类型可以自动调用定义在包装对象上的方法和属性。比如String对象的实例有一个length属性，返回字符串的长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</div><div class="line">v.length <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>所有原始类型的字符串，都可以直接使用这个length属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="string">"abc"</span>.length <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>上面代码对字符串abc调用length属性，实际上是将“字符串”自动转为String对象的实例，再在其上调用length属性。这就叫原始类型的自动转换。</p>
<p>abc是一个字符串，属于原始类型，本身不能调用任何方法和属性。但当对abc调用length属性时，JavaScript引擎自动将abc转化为一个包装对象实例，然后再对这个实例调用length属性，在得到返回值后，再自动销毁这个临时生成的包装对象实例。</p>
<p>这种原始类型值可以直接调用的方法还有很多（详见后文对各包装对象的介绍），除了前面介绍过的valueOf和stringOf方法，还包括三个包装对象各自定义在实例上的方法。。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="string">'abc'</span>.charAt === <span class="built_in">String</span>.prototype.charAt</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码表示，字符串abc的charAt方法，实际上就是定义在String对象实例上的方法（关于prototype对象的介绍参见《面向对象编程》一章）。</p>
<p>如果包装对象与原始类型值进行混合运算，包装对象会转化为原始类型（实际是调用自身的valueOf方法）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) + <span class="number">123</span></div><div class="line"><span class="comment">// 246</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>) + <span class="string">"abc"</span></div><div class="line"><span class="comment">// "abcabc"</span></div></pre></td></tr></table></figure>
<h3 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h3><p>三种包装对象还可以在原型上添加自定义方法和属性，供原始类型的值直接调用。</p>
<p>比如，我们可以新增一个double方法，使得字符串和数字翻倍。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">String</span>.prototype.double = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.valueOf() + <span class="keyword">this</span>.valueOf();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="string">"abc"</span>.double()</div><div class="line"><span class="comment">// abcabc</span></div><div class="line"></div><div class="line"><span class="built_in">Number</span>.prototype.double = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.valueOf() + <span class="keyword">this</span>.valueOf();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">(<span class="number">123</span>).double()</div><div class="line"><span class="comment">// 246</span></div></pre></td></tr></table></figure>
<p>上面代码在123外面必须要加上圆括号，否则后面的点运算符（.）会被解释成小数点。</p>
<p>但是，这种自定义方法和属性的机制，只能定义在包装对象的原型上，如果直接对原始类型的变量添加属性，则无效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> s = <span class="string">"abc"</span>;</div><div class="line"></div><div class="line">s.p = <span class="number">123</span>;</div><div class="line">s.p <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>上面代码直接对支付串abc添加属性，结果无效。</p>
<h2 id="Boolean对象"><a href="#Boolean对象" class="headerlink" title="Boolean对象"></a>Boolean对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Boolean对象是JavaScript的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> b <span class="comment">// "object"</span></div><div class="line">b.valueOf() <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码的变量b是一个Boolean对象的实例，它的类型是对象，值为布尔值true。这种写法太繁琐，几乎无人使用，直接对变量赋值更简单清晰。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</div></pre></td></tr></table></figure>
<h3 id="Boolean实例对象的布尔值"><a href="#Boolean实例对象的布尔值" class="headerlink" title="Boolean实例对象的布尔值"></a>Boolean实例对象的布尔值</h3><p>特别要注意的是，所有对象的布尔运算结果都是true。因此，false对应的包装对象实例，布尔运算结果也是true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>); </div><div class="line">&#125; <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>).valueOf()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>); </div><div class="line">&#125; <span class="comment">// 无输出</span></div></pre></td></tr></table></figure>
<p>上面代码的第一个例子之所以得到true，是因为false对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值true（所有对象对应的布尔值都是true）。而实例的valueOf方法，则返回实例对应的原始类型值，本例为false。</p>
<h3 id="Boolean函数的类型转换作用"><a href="#Boolean函数的类型转换作用" class="headerlink" title="Boolean函数的类型转换作用"></a>Boolean函数的类型转换作用</h3><p>Boolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="number">1</span>) <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="string">'false'</span>) <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>([]) <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="regexp">/foo/</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码中几种得到true的情况，都值得认真记住。</p>
<p>使用not运算符（!）也可以达到同样效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">!!<span class="literal">undefined</span> <span class="comment">// false</span></div><div class="line">!!<span class="literal">null</span> <span class="comment">// false</span></div><div class="line">!!<span class="number">0</span> <span class="comment">// false</span></div><div class="line">!!<span class="string">''</span> <span class="comment">// false</span></div><div class="line">!!<span class="literal">NaN</span> <span class="comment">// false</span></div><div class="line">!!<span class="number">1</span> <span class="comment">// true</span></div><div class="line">!!<span class="string">'false'</span> <span class="comment">// true</span></div><div class="line">!![] <span class="comment">// true</span></div><div class="line">!!&#123;&#125; <span class="comment">// true</span></div><div class="line">!!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// true</span></div><div class="line">!!<span class="regexp">/foo/</span> <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>综上所述，如果要获得一个变量对应的布尔值，有多种写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="string">"hello world"</span>;</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(a).valueOf() <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>(a) <span class="comment">// true</span></div><div class="line">!!a <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>最后，对于一些特殊值，Boolean对象前面加不加new，会得到完全相反的结果，必须小心。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>(<span class="literal">false</span>)) </div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'true'</span>); <span class="comment">// 无输出</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'true'</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>(<span class="literal">null</span>)) </div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'true'</span>); <span class="comment">// 无输出</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">null</span>))</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'true'</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;包装对象&quot;&gt;&lt;a href=&quot;#包装对象&quot; class=&quot;headerlink&quot; title=&quot;包装对象&quot;&gt;&lt;/a&gt;包装对象&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;在JavaScript中，“一切皆对象”，数组和函数本质上都是对象，就连三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。&lt;/p&gt;
&lt;p&gt;所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.houfeng.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB 高可用群集简单配置</title>
    <link href="http://blog.houfeng.net/2013/10/26/2013-10-26-mongodb-replica-set/"/>
    <id>http://blog.houfeng.net/2013/10/26/2013-10-26-mongodb-replica-set/</id>
    <published>2013-10-26T15:22:59.000Z</published>
    <updated>2016-08-27T03:35:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Replica-Set-节点类型分为三种："><a href="#Replica-Set-节点类型分为三种：" class="headerlink" title="Replica Set 节点类型分为三种："></a>Replica Set 节点类型分为三种：</h3><pre><code>standard：常规节点，它存储一份完整的数据副本，参与选举投票，有可能成为primary节点。
passive：存储了完整的数据副本，参与投票，不能成为primary节点。 
arbiter：仲裁节点，只参与投票，不接收复制的数据，也不能成为primary节点。
</code></pre><a id="more"></a>
<p>###节点规划<br>仅做的测试而已，所以所有节点仅是同一台服务器上的三个不同端口的 MongoDB 实例，本文配置使用2个常规节点和一个arbiter节点，arbiter节点由于不同步数据，所以负载会很小，部署对硬件没有太大的要求，<br>因为 MongoDB Replica Set 不允许添加两个 “本地（localhost或127.0.01）节点”，所有首先在系统的 hosts 文件中添加:</p>
<p>  127.0.0.1 mongodb27021<br>  127.0.0.1 mongodb27022<br>    127.0.0.1 mongodb27023</p>
<p>节点规划如下:</p>
<pre><code>mongodb27021:27021 主节点(Primary)
mongodb27022:27022  从节点(Secondary)
mongodb27023:27023 仲裁节点(Arbiter)
</code></pre><p>###启动三个节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod.exe --port=27021 --replSet=rs_test --dbpath=&quot;..\27021\data&quot; --logpath=&quot;..\27021\log\mongodb.log&quot; --smallfiles</div></pre></td></tr></table></figure></p>
<p>其它两个节点用同样的命令，将端口替换为指定的端口，及指定合适的数据库文件及日志存储目录，生产环境，可将 mongodb 安装到系统服务中（很简单 google 一下吧）。</p>
<p>###配置群集<br>mongo -port 27021 连接到其中一个节点。</p>
<p>#####初始化群集:<br>rs.initiate()<br>这个命令可以接收参数，直接配置群集中的各节点，这里简单点直接初始化，27021将成为 Primary 节点。</p>
<p>#####添加从节点<br>rs.add(“mongodb27022:27022”)<br>默认从节点的数据不可 “读写” ，连接到从节点，执行 “rs.salveOk()” 可以使从节点只读，以减少主节点的读压力。</p>
<p>####添加仲裁节点<br>rs.addArb(“mongodb27022:27023”)<br>仲裁节点，不存储数据，只在主节点发生故障时，参与主节点的 “推举”。</p>
<p>至此一个最简单的 Replica Set 高可用群集配置完成。</p>
<p>###检查群集</p>
<ol>
<li>在主节点接入数据，在从节点即可到刚刚接入的数据。</li>
<li>结束到主节点，再连接到从节点用 “rs.isMaster()” 可以看到从节点，已被“推举”为主节点了。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Replica-Set-节点类型分为三种：&quot;&gt;&lt;a href=&quot;#Replica-Set-节点类型分为三种：&quot; class=&quot;headerlink&quot; title=&quot;Replica Set 节点类型分为三种：&quot;&gt;&lt;/a&gt;Replica Set 节点类型分为三种：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;standard：常规节点，它存储一份完整的数据副本，参与选举投票，有可能成为primary节点。
passive：存储了完整的数据副本，参与投票，不能成为primary节点。 
arbiter：仲裁节点，只参与投票，不接收复制的数据，也不能成为primary节点。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://blog.houfeng.net/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>模块的封装与解耦</title>
    <link href="http://blog.houfeng.net/2013/03/17/2013-03-16-module-encapsulation-decoupling/"/>
    <id>http://blog.houfeng.net/2013/03/17/2013-03-16-module-encapsulation-decoupling/</id>
    <published>2013-03-17T05:35:44.000Z</published>
    <updated>2016-08-27T03:34:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>###话题起因<br>回头看自已写过东西，常会感觉到不满意，总有重构冲动（其实这种冲动通常是好事，因为只有发现了不足才有重构想法，只有重构才能改进，只有改进才能完善）。</p>
<a id="more"></a>
<p>最近，准备重构<a href="http://houfeng/mokit" target="_blank" rel="external">mokit</a>，因为这前的mokit虽然有将不同的“模块”分离在不同的文件中，并有“命名空间”概念，但其实现在版本的mokit模块甚至不能称为真正的模块，因为它没有完整“封装”的概念，并且虽有“命名空间”，但还是会创建一部分全局变量，只能依靠开发人员制定好的“契约”，既“非强制约束”的开发规范。</p>
<p>因为现有mokit存在的各种不足，在重构之前一直在思考mokit更合适的结构：</p>
<ol>
<li>更加清析的、真正的模块化的结构；</li>
<li>模块的真正封装；</li>
<li>模块间的最大化解耦；</li>
<li>更加清析的MVC或MVP模式；</li>
</ol>
<p>第一步先实现真的模块封装，及模块中的解耦，第二步实现简洁易用的MVC或MVP的架构及开框架。MVC稍后再谈，这篇博文将就模块化、封装、解耦做一些控讨。</p>
<p>###模块的封装</p>
<p>#####百度百科:<br>模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性<br>模块化是一种处理复杂系统分解为更好的可管理模块的方式。</p>
<p>模块化用来分割，组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能。<br>模块具有以下几种基本属性：接口、功能、逻辑、状态，功能、状态与接口反映模块的外部特性，逻辑反映它的内部特性。<br>在系统的结构中，模块是可组合、分解和更换的单元。模块化是一种处理复杂系统分解成为更好的可管理模块的方式。它可以通过在不同组件设定不同的功能，把一个问题分解成多个小的独立、互相作用的组件，来处理复杂、大型的软件。</p>
<p>#####实现模块封装:<br>在完整面向对象的语言中可能是一个类，封装作为OOP三大特性：封装、多态、继承之一，在这些有完整OOP机制的语言实现模块的封装非常容易</p>
<p>如在C#中</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">string</span> Ident&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在C#中，一个类（模块）可以方便的声明“私有成员”，实现封装特性；</p>
<p>而在JavaScript中实现就稍显“麻烦”，而且写法是各种各样，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Module1=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> ident=<span class="string">""</span>;</div><div class="line">	<span class="keyword">var</span> name=<span class="string">""</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">    	getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        	<span class="keyword">return</span> name;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>上边在JavaScript的自执行函数中，通过var定议的变量，在函数外部不能被访问也实现了封装。<br>事实上，JavaScript的有很多模块化的库，能够实现更加完整的模块定义，如RequireJS、EmsJs。</p>
<p>###模块的依赖<br>当程序采用模块化的结构后，不同的功能都分布在不同的模块中，必然存在模块相互调用的问题，这时就需要管理好模块之间的依赖关系；</p>
<p>依赖常常表直观的表现为：</p>
<ol>
<li>在一个包中import另一个包；</li>
<li>在一个类中调用另一个类或存在加一个类的引用；</li>
<li>在一个js文件中用别一个js文件中定议的对象或函数；</li>
</ol>
<p>如在C#中：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> calss A</div><div class="line">&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span> A _a=<span class="keyword">new</span> A();</div><div class="line">	<span class="keyword">public</span> A a</div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">get</span></div><div class="line">        &#123;</div><div class="line">        	<span class="keyword">return</span> _a;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上代码类“B”事实上对类“A”存在“依赖”，在没有A的时候，B是不完整的，是无法使用的；当要替换A的时候需重新编写B，这样其实A、B之间的“耦合”非常高。</p>
<p>这里是假设每一个类就是一个模块，其实，上有时模块的粒度不能到一个类一个模块，我们也不需要每一个类都要“解耦”，但是上边的示例代码，却能“高耦合”的代码带的的问题；</p>
<p>我曾见过一定情况下很“二”的写法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IA</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span> : <span class="title">IA</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span> IA _a=<span class="keyword">new</span> A();</div><div class="line">	<span class="keyword">public</span> IA a</div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">get</span></div><div class="line">        &#123;</div><div class="line">        	<span class="keyword">return</span> _a;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span>&#123;</div><div class="line">        	_a=<span class="keyword">value</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，或许写代码的人一定是想用interface实现A、B间的“解耦”，实际上还不到位，B对A的依赖依然存在，没有任何意义；</p>
<p>###模块间的解耦</p>
<p>#####依赖反转:<br>在面向对象编程领域中，依赖反转原则（Dependency inversion principle）指代了一种特定的解耦（传统的依赖关系建立在高层次上，而具体的策略设置则应用在低层次的模块上）形式。在这种形势下，为了使得高层次的模块不依赖于低层次的模块的实现细节的目的，依赖模块被颠倒了（例如：反转）。该原则规定：<br>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。<br>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。<br>该原则颠倒了一部分人对于面向对象设计的认识方式，比如高层次和低层次对象都应该应该依赖于相同的抽象接口</p>
<p>改掉这很“二”的写法，如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IA</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span> : <span class="title">IA</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span> IA _a=<span class="literal">null</span>;</div><div class="line">	<span class="keyword">public</span> IA a</div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">get</span></div><div class="line">        &#123;</div><div class="line">        	<span class="keyword">if</span>(_a==<span class="literal">null</span>)</div><div class="line">            &#123;</div><div class="line">            	<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"IA没有找到"</span>);</div><div class="line">            &#125;</div><div class="line">        	<span class="keyword">return</span> _a;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span>&#123;</div><div class="line">        	_a=<span class="keyword">value</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这B、A没有强制依赖了，在更换A的时间，也无须动B中的代码，或许我们是用B前的某一个地主将IA的一个实现类实例传给了B，也有可能是基于配置文件及“反射”完成的。</p>
<p>比如，一个插件式的应用程序！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###话题起因&lt;br&gt;回头看自已写过东西，常会感觉到不满意，总有重构冲动（其实这种冲动通常是好事，因为只有发现了不足才有重构想法，只有重构才能改进，只有改进才能完善）。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://blog.houfeng.net/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>最快,最简洁的javascript模板引擎jtp</title>
    <link href="http://blog.houfeng.net/2013/03/11/2012-10-13-fast-javascript-template-engine-jtp/"/>
    <id>http://blog.houfeng.net/2013/03/11/2012-10-13-fast-javascript-template-engine-jtp/</id>
    <published>2013-03-11T12:26:03.000Z</published>
    <updated>2016-08-27T03:33:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="欢迎来到jtp的世界"><a href="#欢迎来到jtp的世界" class="headerlink" title="欢迎来到jtp的世界"></a>欢迎来到jtp的世界</h3><blockquote>
<p>欢迎使用jtp! 最轻量，简洁，高效的javascript模板引擎！<br>如同“jtp”的名字，“轻量、简洁、高效”是jtp的哲学！</p>
</blockquote>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ 轻量，jtp是目前能见到最轻量的javascript模板引擎，只有一个不足1.5k的文件。</div><div class="line">+ 简洁，jtp的语法非常简单，对于一个熟悉html、js的开发人员来说学习难度为0。</div><div class="line">+ 高效，jtp支持模板预编译，快于任何一个你所见过的javascript模板引擎。</div><div class="line">+ 另外，jtp同时支持在浏览器环境使用及服务端javascript环境(Node.js)使用。</div></pre></td></tr></table></figure>
<h3 id="许可协议"><a href="#许可协议" class="headerlink" title="许可协议"></a>许可协议</h3><blockquote>
<p><a href="http://www.gnu.org/licenses/lgpl.html" target="_blank" rel="external">使用jtp请您遵守LGPL协议，否则您将会被起诉。（点击可查看LGPL协议）</a></p>
</blockquote>
<h3 id="在线demo"><a href="#在线demo" class="headerlink" title="在线demo"></a>在线demo</h3><blockquote>
<p><a href="http://code.houfeng.net/demos/jtp/" target="_blank" rel="external">体验在线demo</a></p>
</blockquote>
<h3 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ 您可以发邮件到 admin@xhou.net</div><div class="line">+ 或者访问 http://www.houfeng.net</div><div class="line">+ 关注微博 http://weibo.com/houfeng</div></pre></td></tr></table></figure>
<h3 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h3><h5 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ 下载jtp</div><div class="line">+ 将jtp.js或jtp-min.js放到项目中合适的位置。</div><div class="line">+ 在相关页面用&lt;script src=&apos;jtp的url&apos;&gt;&lt;/script&gt;引入jtp。</div></pre></td></tr></table></figure>
<h4 id="解析-jtp-parse"><a href="#解析-jtp-parse" class="headerlink" title="解析(jtp.parse)"></a>解析(jtp.parse)</h4><p>代码:</p>
<pre><code>var html=&apos;&lt;div&gt;My name is &lt;@$(this.name)@&gt;&lt;/div&gt;&apos;;
var rs=jtp.parse(html,{name:&apos;jtp&apos;});
</code></pre><p>结果: </p>
<pre><code>&lt;div&gt;My name is jtp&lt;/div&gt;
</code></pre><h4 id="编译-jtp-complite"><a href="#编译-jtp-complite" class="headerlink" title="编译(jtp.complite)"></a>编译(jtp.complite)</h4><p>代码:</p>
<pre><code>var html=&apos;&lt;div&gt;My name is &lt;@$(this.name)@&gt;&lt;/div&gt;&apos;;
var fn=jtp.complite(html);
var rs=fn({name:&apos;jtp&apos;});
</code></pre><p>结果:</p>
<pre><code>&lt;div&gt;My name is jtp&lt;/div&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;欢迎来到jtp的世界&quot;&gt;&lt;a href=&quot;#欢迎来到jtp的世界&quot; class=&quot;headerlink&quot; title=&quot;欢迎来到jtp的世界&quot;&gt;&lt;/a&gt;欢迎来到jtp的世界&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;欢迎使用jtp! 最轻量，简洁，高效的javascript模板引擎！&lt;br&gt;如同“jtp”的名字，“轻量、简洁、高效”是jtp的哲学！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://blog.houfeng.net/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>回忆“Adobe　Web创意训练营第一期”</title>
    <link href="http://blog.houfeng.net/2013/01/28/2013-01-24-Adobe-Web-HTML5/"/>
    <id>http://blog.houfeng.net/2013/01/28/2013-01-24-Adobe-Web-HTML5/</id>
    <published>2013-01-28T14:23:17.000Z</published>
    <updated>2016-08-27T03:33:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>###回忆“Adobe　Web创意训练营第一期”</p>
<p>说是回忆，其实也就是昨天的事儿。</p>
<p>过去一年，才是回忆，我、我所在的团队主要的工作，就是基于HTML5的移动App开发，我们为我们的两家客户基于HTML5分别开发两个完整的“差旅类”的App。</p>
<ol>
<li>CWT Online China</li>
<li>差旅随行</li>
</ol>
<a id="more"></a>
<hr>
<p>对于HTML5的Webapp的开发从简单了解到较为深入的理解，这个过程我们遇到了不少的问题；我们尝试用巧秒的当然也拙劣的方式去试图解决遇到的每一个问题，实现我们认为很有趣儿、好玩的小创意或常规功能；</p>
<p>当然还会有些问题，在一定条件下似乎是无解的或真的无解的，比如“安卓系统的HTMML5的性能问题”；带着疑问和中霏同学去了”Adobe Web 创意训练营第一期”；</p>
<p>实话说，昨儿的讲座，并没有解决我的问题；</p>
<p>但是，之前我现在所在的这团队，可以称之为”闭门造车”（不表示我们造的”车“不好，相反或许还挺棒）；但总有一种疑虑，去怀疑我们的做法是否正确？是否有更好的做法？</p>
<p>所以，想去看看，别的团队是如何做的；去和其它做同样事儿的一群人，去交流，去切磋，去学习；</p>
<p>我们或者我，也很乐于和对前端、前沿技术有兴趣的同志们，一道高讨论有趣、好玩的东西；</p>
<p>这是本此活动对我来说比较重要的一个意义；也是我们继续参加接下来活动的重要的理由；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###回忆“Adobe　Web创意训练营第一期”&lt;/p&gt;
&lt;p&gt;说是回忆，其实也就是昨天的事儿。&lt;/p&gt;
&lt;p&gt;过去一年，才是回忆，我、我所在的团队主要的工作，就是基于HTML5的移动App开发，我们为我们的两家客户基于HTML5分别开发两个完整的“差旅类”的App。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CWT Online China&lt;/li&gt;
&lt;li&gt;差旅随行&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="闲谈" scheme="http://blog.houfeng.net/categories/%E9%97%B2%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器页面渲染之“reflow”</title>
    <link href="http://blog.houfeng.net/2013/01/05/2012-12-27-browser-page-reflow/"/>
    <id>http://blog.houfeng.net/2013/01/05/2012-12-27-browser-page-reflow/</id>
    <published>2013-01-05T02:19:33.000Z</published>
    <updated>2016-08-27T03:36:46.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>###基本概念<br>浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构（geometries）的进程叫做 reflow（回流）。有时 reflow 页面中的一个元素会 reflow 它的祖先元素以及所有子元素。<br>由于 reflow 的开销非常之大，因此要尽可能的避免 reflow 的发生。</p>
<p>###产生 reflow 的原因</p>
<ol>
<li>调整窗口大小；</li>
<li>改变字体；</li>
<li>增加或者移除样式表；</li>
<li>内容变化，比如用户在 input 框中输入文字；</li>
<li>激活 CSS 伪类，比如 :hover (IE 中为兄弟结点伪类的激活)；</li>
<li>操作 class 属性；</li>
<li>脚本操作 DOM；</li>
<li>计算 offsetWidth 和 offsetHeight 属性；</li>
<li>设置 style 属性的值。</li>
</ol>
<p>###如何减少 reflow</p>
<ol>
<li>如果想设定元素的样式，通过改变元素的 class 名 (尽可能在 DOM 树的最里层)；</li>
<li>避免设置多项内联样式；</li>
<li>用于表现动画的元素，使用 position 属性的 fixed 值或 absolute 值（脱离文档流）；</li>
<li>权衡平滑和速度（调大每帧间隔，减少 reflow 次数）；</li>
<li>避免使用 table 布局；</li>
<li>避免使用CSS的 JavaScript 表达式 (仅 IE 浏览器)；</li>
<li>减少不必要的 DOM 层级，改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点；</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;###基本概念&lt;br&gt;浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构（geometries）的进程叫做 reflow（回流）。有时 reflow 页面中的一个元素会 reflow 它的祖先元素以及所有子元素。&lt;br&gt;由于
    
    </summary>
    
      <category term="前端" scheme="http://blog.houfeng.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>mac系统如何显示和隐藏文件</title>
    <link href="http://blog.houfeng.net/2013/01/05/2012-12-06-mac-show-all-files/"/>
    <id>http://blog.houfeng.net/2013/01/05/2012-12-06-mac-show-all-files/</id>
    <published>2013-01-05T02:19:33.000Z</published>
    <updated>2016-08-27T03:33:31.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>###mac系统如何显示和隐藏文件<br>苹果Mac OS X操作系统下，隐藏文件是否显示有很多种设置方法，最简单的要算在Mac终端输入命令。显示/隐藏Mac隐藏文件命令如下(注意其中的空格并且区分大小写)：   </p>
<a id="more"></a>
<p>显示Mac隐藏文件的命令：defaults write com.apple.finder AppleShowAllFiles -bool true</p>
<p>隐藏Mac隐藏文件的命令：defaults write com.apple.finder AppleShowAllFiles -bool false</p>
<p>或者</p>
<p>显示Mac隐藏文件的命令：defaults write com.apple.finder AppleShowAllFiles  YES</p>
<p>隐藏Mac隐藏文件的命令：defaults write com.apple.finder AppleShowAllFiles  NO</p>
<p>输完单击Enter键，退出终端，重新启动Finder就可以了</p>
<p>重启Finder：鼠标单击窗口左上角的苹果标志–&gt;强制退出–&gt;Finder–&gt;重新启动</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;###mac系统如何显示和隐藏文件&lt;br&gt;苹果Mac OS X操作系统下，隐藏文件是否显示有很多种设置方法，最简单的要算在Mac终端输入命令。显示/隐藏Mac隐藏文件命令如下(注意其中的空格并且区分大小写)：   &lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>如何制作越狱版本iOS软件</title>
    <link href="http://blog.houfeng.net/2012/10/29/2012-10-20-How-to-make-escape-version-IOS-software/"/>
    <id>http://blog.houfeng.net/2012/10/29/2012-10-20-How-to-make-escape-version-IOS-software/</id>
    <published>2012-10-29T15:43:26.000Z</published>
    <updated>2016-08-27T03:33:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>###如何制作一个越狱版本的ios应用？</p>
<ol>
<li>编译生成Distribution版本的程序</li>
<li>右击生成的程序，选择显示包内容，选择Info.plist文件添加字段：SigerIdentity，字段值：Apple OS Application Signing</li>
<li>创建Payload文件夹，将程序拖进，压缩并更改压缩后缀为*.ipa</li>
<li>拖进生成的ipa文件于iTurns或通过同步工具安装即可</li>
</ol>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###如何制作一个越狱版本的ios应用？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译生成Distribution版本的程序&lt;/li&gt;
&lt;li&gt;右击生成的程序，选择显示包内容，选择Info.plist文件添加字段：SigerIdentity，字段值：Apple OS Application Signing&lt;/li&gt;
&lt;li&gt;创建Payload文件夹，将程序拖进，压缩并更改压缩后缀为*.ipa&lt;/li&gt;
&lt;li&gt;拖进生成的ipa文件于iTurns或通过同步工具安装即可&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>移动web开发局部区域滚动问题</title>
    <link href="http://blog.houfeng.net/2012/10/13/2012-09-29-mobile-dev-overflow-scroll/"/>
    <id>http://blog.houfeng.net/2012/10/13/2012-09-29-mobile-dev-overflow-scroll/</id>
    <published>2012-10-13T11:37:59.000Z</published>
    <updated>2016-08-27T03:33:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>###问题<br>开发一个针对pc的web应用时，在需要不随内容滚动的页头或面页脚时，通常的做法是如下样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.ui-head</span>&#123; <span class="attribute">position</span>:fixed; &#125;</div></pre></td></tr></table></figure></p>
<p>但是如上的样式放到手机上，我测试过android2.x、android4.x、ios4.x皆不支持position:fixed;</p>
<a id="more"></a>
<p>但经过测试，发现ios5.x已经支持position:fiexd,但通过position:fiexd一般只能实现页整的整体滚动时页头或页脚的固定，在实现页面某一小区域的滚动效果还是不太方便。</p>
<p>另外一种方式，是指定一个元素（通常是DIV）的高度或宽度，然后使定义如下样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.ui-content</span> &#123;<span class="attribute">height</span>:<span class="number">300px</span>;<span class="attribute">overflow</span>:auto;&#125;</div></pre></td></tr></table></figure></p>
<p>但经过测试，目前的主流的设备均不支持 overflow 样式。</p>
<p>###通过webkit特有的样式实现<br>经测试ios5.1已支持如下样式定义：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-webkit-overflow-scrolling</span>: <span class="selector-tag">touch</span>;</div></pre></td></tr></table></figure></p>
<p>通过如上定义，ios5.x可以样式（不用js）实现局部区域滚动；但目前我试过android2.x及android4.x发现依然不支持些样式。</p>
<p>###通过javascript实现<br>为了实现兼容主流平台及浏览器，常见的做法（很多web开发框架就是依赖javascript实现），如轻量易用的优秀开源组件 iScroll 4 </p>
<p>而通过js实现局部滚动，一般如下几种方式：</p>
<ol>
<li>定义样式 overflow:hidden， 然后处理touchstart、touchmove、touchend事件，控制scrollTop完成滚动功能，此种方式较为简洁，并易于实现。</li>
<li>定义样式 overflow:hidden，并且要求容器内的元素必须有一个内层嵌套外层单一元素比如：<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui-scroll"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui-scroll-inner"</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>然后去控制内层元素的margin-top或margin-left。此种方式稍现麻烦，但可以使用css3的transform2d 控制内层元素translate来实现（此种方法在某些设备上能获得较好的性能）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###问题&lt;br&gt;开发一个针对pc的web应用时，在需要不随内容滚动的页头或面页脚时，通常的做法是如下样式：&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.ui-head&lt;/span&gt;&amp;#123; &lt;span class=&quot;attribute&quot;&gt;position&lt;/span&gt;:fixed; &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是如上的样式放到手机上，我测试过android2.x、android4.x、ios4.x皆不支持position:fixed;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://blog.houfeng.net/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>最易于使用的asp.net ajax框架</title>
    <link href="http://blog.houfeng.net/2012/10/13/2012-02-10-ajaxengine-dotnet/"/>
    <id>http://blog.houfeng.net/2012/10/13/2012-02-10-ajaxengine-dotnet/</id>
    <published>2012-10-13T11:37:59.000Z</published>
    <updated>2016-08-27T03:37:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址: <a href="http://www.houfeng.net/page/AjaxEngine.aspx" target="_blank" rel="external">http://www.houfeng.net/page/AjaxEngine.aspx</a></p>
<a id="more"></a>
<p>###2009年中<br>工作之余写了一个简单非常方便使用Ajax框架（应该还称不是框架）！并用一个小仓库管理项目<br>2009年末，确实是年末2009-12-29，写了一篇文章，介如年中所写的“框架”;<br>文章地址：<a href="http://www.cnblogs.com/houfeng/archive/2009/12/29/1635350.html" target="_blank" rel="external">http://www.cnblogs.com/houfeng/archive/2009/12/29/1635350.html</a></p>
<p>###2010年初<br>移植了一个java版本，并送于一个朋友，java版本之后我没维护，java版本被朋友用于了几个政府项目！具说现在他还在用着，但我已不知道“它”长成什么样了！<br>还是2010年，用于了当时参与的一个OA项目，及一个短信平台项目，此时AjaxEngine已添加很多功能：<br>可以让所有微软官方asp.net控件具备Ajax能力。<br>可以轻松在前端页面调用页面中服务端方法，并异步更新页面呈现。<br>可以在服务端轻松调用客户端脚本。</p>
<p>###2011年<br>AjaxEngine被用于国内某大型证券企业OA的部分模块！<br>还是2011年，优化了性能，增加了快速编写JsonHandler相关功能！</p>
<p>###2012年<br>正式开源！</p>
<p>###为什么开源？<br>本来不是什么高深的东西，为什么如数家珍呢？不如分享！<br>因为AjaxEngine虽实现了相关功能，使用也非常简单方便！但也一直想着好好优化一下，但总不知是真没时间还是偷懒，以致于到现在AjaxEngine中还有09年我刚毕业时写的较为拙劣的代码！希望更多的人参于，优化AjaxEngine<br>AjaxEngine的思路还是较为巧妙的！<br>希望让更多的coder快速完成ajax开发！<br>希望更多的人提出议见以改进AjaxEngine！</p>
<p>###AjaxEngine的使用不用任何配置，使用步骤如下：</p>
<ol>
<li>添加对AjaxEngine的引用</li>
<li>页面继承AjaxPageBase，或实现IAjaxPage 即可</li>
<li>JsonHandler继承JsonHandlerBase即可</li>
<li>用AjaxMethod标记相关法！</li>
</ol>
<p>###DEMO</p>
<p>页面使用Demo:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">using AjaxEngines;</div><div class="line">namespace AjaxEngine.Demo</div><div class="line">&#123;</div><div class="line">   	public partial class _Default : AjaxPageBase</div><div class="line">   	&#123;</div><div class="line">       	protected void Page_Load(object sender, EventArgs e)</div><div class="line">       	&#123;</div><div class="line">       	&#125;</div><div class="line">       	protected void Button1_Click(object sender, EventArgs e)</div><div class="line">       	&#123;</div><div class="line">           	this.AjaxEngine.ShowMessageBox("houfeng");</div><div class="line">       	&#125;</div><div class="line">       	/// &lt;summary&gt;</div><div class="line">       	/// 参数和返回值都必须是string类型</div><div class="line">       	/// &lt;/summary&gt;</div><div class="line">       	/// &lt;param name="x"&gt;&lt;/param&gt;</div><div class="line">       	/// &lt;param name="y"&gt;&lt;/param&gt;</div><div class="line">       	/// &lt;returns&gt;&lt;/returns&gt;</div><div class="line">       	[AjaxMethod]</div><div class="line">       	public string  Add(string x, string y)</div><div class="line">       	&#123;</div><div class="line">           	return (x + y).ToString();</div><div class="line">       	&#125;</div><div class="line">   	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Handler使用Demo:</p>
<p>服务端:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> AjaxEngines;</div><div class="line"><span class="keyword">using</span> AjaxEngines.JsonHandlers;</div><div class="line"><span class="keyword">namespace</span> <span class="title">AjaxEngine.Demo</span></div><div class="line">&#123;</div><div class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></div><div class="line">    <span class="comment"><span class="doctag">///</span> Handler1 的摘要说明</span></div><div class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Handler1</span> : <span class="title">JsonHandlerBase</span></div><div class="line">  &#123;</div><div class="line">      [AjaxMethod]</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span></div><div class="line">      &#123;</div><div class="line">          <span class="keyword">return</span> x + y;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.getJSON(<span class="string">"Handler1.ashx"</span>, &#123; method: <span class="string">"add"</span>, x: <span class="number">1</span>, y: <span class="number">2</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">dt</span>) </span>&#123;</div><div class="line">      alert(dt);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目地址: &lt;a href=&quot;http://www.houfeng.net/page/AjaxEngine.aspx&quot;&gt;http://www.houfeng.net/page/AjaxEngine.aspx&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://blog.houfeng.net/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>禁用CentOS Linux系统的图形界面</title>
    <link href="http://blog.houfeng.net/2012/09/16/2012-09-15-linux-centos-disabled-gui-start/"/>
    <id>http://blog.houfeng.net/2012/09/16/2012-09-15-linux-centos-disabled-gui-start/</id>
    <published>2012-09-15T17:04:26.000Z</published>
    <updated>2016-08-27T03:32:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何禁用Centos GUI图形界面？</p>
<a id="more"></a>
<p>vi /etc/inittab</p>
<p>把默认的</p>
<p>id:5:initdefault:</p>
<p>改成</p>
<p>id:3:initdefault:</p>
<p>这样登录的默认界面就是字符界面了， 需要gui时， startx 即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何禁用Centos GUI图形界面？&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>linux系统防火墙简单设置</title>
    <link href="http://blog.houfeng.net/2012/09/16/2012-09-15-linux-firewall/"/>
    <id>http://blog.houfeng.net/2012/09/16/2012-09-15-linux-firewall/</id>
    <published>2012-09-15T17:03:07.000Z</published>
    <updated>2016-08-27T03:32:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux还是比较常用的，于是我研究了一下Linux关闭防火墙命令，在这里拿出来和大家分享一下，希望你能学会Linux关闭防火墙命令 。</p>
<a id="more"></a>
<p>###永久性生效，重启后不会复原</p>
<p>开启： chkconfig iptables on</p>
<p>关闭： chkconfig iptables off</p>
<p>###即时生效，重启后复原</p>
<p>开启： service iptables start</p>
<p>关闭： service iptables stop</p>
<hr>
<p>需要说明的是对于Linux下的其它服务都可以用以上命令执行开启和关闭操作。</p>
<p>在开启了防火墙时，做如下设置，开启相关端口，</p>
<p>修改/etc/sysconfig/iptables 文件，添加以下内容：<br>-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT<br>-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux还是比较常用的，于是我研究了一下Linux关闭防火墙命令，在这里拿出来和大家分享一下，希望你能学会Linux关闭防火墙命令 。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>.net编写的外挂式绿色五笔</title>
    <link href="http://blog.houfeng.net/2012/09/14/2009-10-29-input-green-wubi/"/>
    <id>http://blog.houfeng.net/2012/09/14/2009-10-29-input-green-wubi/</id>
    <published>2012-09-14T05:04:19.000Z</published>
    <updated>2016-08-27T03:30:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="绿色五笔概述"><a href="#绿色五笔概述" class="headerlink" title="绿色五笔概述:"></a>绿色五笔概述:</h3><p>绿色五笔,名字瞎起的.采用.net开发(不知道是不是第一个,呵呵),目前仅一个beta版,好几个月前这样了,最近没有更新.<br>其中部分词库来自万能五笔.<br>无需安装,只需运行GreenWb.exe即可.第一次运行会自动加入自启动.可在设置中取消自启动.</p>
<a id="more"></a>
<p>###截图</p>
<p>输入窗口:</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/houfeng/20091029122614_1.jpg" alt=""></p>
<p>设置窗口:</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/houfeng/20091029122615_2.jpg" alt=""></p>
<p>字词编辑器:</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/houfeng/20091029122615_3.jpg" alt=""></p>
<p>###一些设置:</p>
<ol>
<li>单击输入法窗口 中/英 按钮,切换中英文(Shift 中英文切换).</li>
<li>单击输入法窗口 半/全 按钮,切换全半角.</li>
<li>单击输入法窗口 简/繁 按钮,切换简繁输入.</li>
<li>单击输入法窗口 词 按钮,将当前选中文字加入新词.</li>
<li>单击输入法窗口 关 按钮,最小化输入窗口.</li>
<li>单击输入法窗口 ./。 按钮,切换中英文标点(暂不输入中文标点).</li>
<li>右击任务栏图标，字词库 管理用户词库.</li>
<li>右击任务栏图标，设置 进行软件基本设置.</li>
</ol>
<p>###下载:</p>
<p>单击这里下载试用</p>
<hr>
<p>欢迎各位建义.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;绿色五笔概述&quot;&gt;&lt;a href=&quot;#绿色五笔概述&quot; class=&quot;headerlink&quot; title=&quot;绿色五笔概述:&quot;&gt;&lt;/a&gt;绿色五笔概述:&lt;/h3&gt;&lt;p&gt;绿色五笔,名字瞎起的.采用.net开发(不知道是不是第一个,呵呵),目前仅一个beta版,好几个月前这样了,最近没有更新.&lt;br&gt;其中部分词库来自万能五笔.&lt;br&gt;无需安装,只需运行GreenWb.exe即可.第一次运行会自动加入自启动.可在设置中取消自启动.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://blog.houfeng.net/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>新博客第一篇文章</title>
    <link href="http://blog.houfeng.net/2012/09/14/2012-09-10-first-blog/"/>
    <id>http://blog.houfeng.net/2012/09/14/2012-09-10-first-blog/</id>
    <published>2012-09-14T05:04:19.000Z</published>
    <updated>2016-08-27T03:31:28.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>###基于Github Pages搭建的轻型博客<br>最近一直在找一个简洁高效的博客程序，也想动手写一个符合自己的博客程序，实话说：不只是想了，已经基于node.js开始写了，但因为最近工作较忙，一直没有时间将其完全开发完成。</p>
<p>Githab Pages一直以来也在用，比如我的几个开源项目的相关页面，今天开始用Githab Pages构建我的静态博客。特记！</p>
<p>###在此之前的博文<br>在些之前的文章一直发表在博客园，之前文章将不会特意导入到在的博客中，部分导过来文章，因为日期早于此篇文章，将在出现在“新博客第一篇文章”之前的时间。阅读以前的文章请访问:<a href="http://houfeng.cnblogs.com" target="_blank" rel="external">http://houfeng.cnblogs.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;###基于Github Pages搭建的轻型博客&lt;br&gt;最近一直在找一个简洁高效的博客程序，也想动手写一个符合自己的博客程序，实话说：不只是想了，已经基于node.js开始写了，但因为最近工作较忙，一直没有时间将其完全开发完成。&lt;/p&gt;

    
    </summary>
    
      <category term="闲谈" scheme="http://blog.houfeng.net/categories/%E9%97%B2%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>图象处理常用特效算法</title>
    <link href="http://blog.houfeng.net/2012/09/14/2009-07-23-image-handle/"/>
    <id>http://blog.houfeng.net/2012/09/14/2009-07-23-image-handle/</id>
    <published>2012-09-14T05:04:19.000Z</published>
    <updated>2016-08-27T03:38:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍几个图像处理常用算法</p>
<a id="more"></a>
<p>###图像的逆反处理算法<br>逆反处理的算法如下：<br>设r，g，b分别为源图像像素f（i，j）的红，绿，蓝分量值，rr，gg，bb分别为处理后像素g（i，j）的红，绿，蓝分量值。则<br>rr=255-r<br>gg=255-g<br>bb=255-b</p>
<p>###图像的平滑处理<br>算法如下：<br>平滑处理是指将源图像的每一个像素的颜色值由其相邻n X n个像素的平均值来代替。<br>例如，对于3*3点阵而言，设原图像某像素的值为f（i，j），平滑处理后该像素的值为g（i，j），则：<br>g(i,j)=(f(i,j)+f(i-1,j)+f(i+1,j)+f(i-1,j-1)+f(i,j-1)+f(i+1,j-1)+<br>f(i-1,j+1)+f(i,j+1)+f(i+1,j+1))/9<br>注意：该算法不能平滑图像边界的像素。</p>
<p>###图象的霓虹处理<br>算法：<br>对于3 X 3点阵，首先计算原图象像素f(i,j)的红，绿，蓝分量与相同行f（i+1，j）及同列f(i,j+1)相邻象素的梯度，即差的平方之和的平方根，然后将梯度值作为处理后的象素g(i,j)的红，绿，蓝分量值。<br>设 r1,g1,b1分别为原图象象素f(i,j)的红，绿，蓝分量值，r2,g2,b2分别为相同行相邻象素f(i+1,j)的红，绿，蓝分量值，r3,g3,b3分别为同列相邻象素f(i,j+1)的红，绿，蓝分量值，rr,gg,bb为处理后象素g(i,j)的红，绿，蓝分量值，则：<br>rr1=(r1-r2)^2  rr2=(r1-r3)^2<br>gg1=(g1-g2)^2  gg2=(g1-g3)^2<br>bb1=(b1-b2)^2  bb2(b1-b3)^2<br>rr=2 X (rr1+rr2)^0.5<br>gg=2 X (gg1+gg2)^0.5<br>bb=2 X (bb1+bb2)^0.5</p>
<p>###图象的锐化处理<br>锐化处理的算法：<br>计算原图像像素f(i,j)的像素值与该像素与相邻像素f(i-1,j-1)像素值之差的绝对值得百分比之和，作为处理后图像像素g(i,j)的像素值。例如，设r1,g1,b1分别为f(i,j)的红、绿、蓝分量值，r2,g2,b2分别为f(i-1,j-1)的红、绿、蓝分量值，rr,gg,bb分别为g(i,j)的红、绿、蓝分量值，则：<br>rr=r1+0.25 X abs(r1-r2)<br>gg=g1+0.25 Ｘ abs(g1-g2)<br>bb=b1+0.25 Ｘabs(b1-b2)</p>
<p>###图像的浮雕处理<br>算法：<br>位图图像的浮雕处理的算法是：<br>g(i,j)=f(i,j)-f(i-1,j)+常数<br>式中，g(i,j)为处理后图像的像素值，f(i,j)为原图像的像素值，f(i-1,j)为前一个相邻像素的值。常数一般取128，即<br>rr=r1-r2+128<br>gg=g1-g2+128<br>bb=b1-b2+128<br>式中，r1,g1,b1分别为原图像的像素f(i,j)的红、绿、蓝分量值；r2,g2,b2分别为前一个相邻像素f(i-1,j)的红、绿、蓝分量值，rr,gg,bb,分别为处理后图像的像素g(i,j)的红、绿、蓝分量值.<br>６.图像的镶嵌处理<br>镶嵌处理算法如下：<br>镶嵌处理后的图像每一小矩阵内的所有像素值都取此矩阵内原图像各像素值之和的平均值。例如，对于3*3的子域：<br>g(i,j)=(f(i,j)+f(i-1,j)+f(i+1,j)+f(i-1,j-1)+f(i+1,j-1)+f(i-1,j+1)+f(i,j+1)+f(i+1,j+1))/9<br>则取：<br>g(i-1,j)=g(i,j)<br>g(i+1,j)=g(i,j)<br>g（i,j-1）=g(i,j)<br>g(i,j+1)=g(i,j)<br>g(i,j+1)=g(i,j)<br>g(i-1,j-1)=g(i,j)<br>g(i-1,j+1)=g(i,j)<br>g(i+1,j-1)=g(i,j)<br>g(i+1,j+1)=g(i,j)</p>
<p>###图像的灰度处理<br>彩色图像灰度处理的算法如下：<br>c=tuxing.GetPixel(i,j)<br>r=c.R<br>g=c.G<br>b=c.B<br>rr=g(r 64)X64<br>gg=(g 64)X64<br>bb=(b 64)X64</p>
<p>###图像缩小处理<br>以坐标原点为中心，将图像个像素坐标的X分量和Y分量分别乘以Sx，Sy，则可使图像进行整体放大和缩小。这时，<br>X’=X x Sx<br>Y’=Y x Sy<br>当Sx=Sy时，作相似变换;<br>当Sx!=Sy时，产生变形。<br>９.图像的平移处理<br>图像的平移变换是将图形上的点（x,y)在x方向（水平方向）和y方向（垂直方向）<br>分别移动dx和dy,则变换后点(x’,y’)坐标值为：<br>x’=x+dx<br>y’=y+dy</p>
<p>###图像的旋转变换<br>二维图像的旋转变换是以原点为中心，将点（x,y）旋转a角度而得到新的坐标（x’,y’）的变换称为旋转变换。其数学表达式为：<br>x’=x x cosa-y x sina<br>y’=x x sina+y x cosa<br>１１.二维图像的对称变换<br>二维图像对称变换有以下几种情况.<br>1.以x轴为对称得对称变换。<br>以x轴为对称得点(x,y)的对称点(x’,y’)坐标为：<br>x’=x<br>y’=-y<br>2.以y轴为对称得对称变换。<br>以y轴为对称的点（x,y）的对称点(x’,y’)坐标为：<br>x’=-x<br>y’=y<br>3.以原点为对称的对称变换。<br>以原点为对称得点（x,y）的对称点（x’,y’）坐标为：<br>x’=-x<br>y’=-y<br>对图像的每一个像素依据二维图形几何变换公式进行计算后，在进行图像显示，则可得到图像的几何变换。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍几个图像处理常用算法&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://blog.houfeng.net/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>eclipse+tomcat web工程引用其它工程</title>
    <link href="http://blog.houfeng.net/2012/09/12/2012-09-11-eclipse-tomcat-webproject/"/>
    <id>http://blog.houfeng.net/2012/09/12/2012-09-11-eclipse-tomcat-webproject/</id>
    <published>2012-09-12T05:03:13.000Z</published>
    <updated>2016-08-27T03:31:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>之前用eclipse做android开发的时候，一个工程项目引用的方式引用另一个工程，一直没有问题。今天为一个web工程引用另一个工程的时候，编译运行发生找不到“类”的错误。</p>
</blockquote>
<a id="more"></a>
<p>###解决方法</p>
<ol>
<li>选中web工程</li>
<li>按下alt键</li>
<li>按下enter键</li>
<li>在Deployment Assembly中添加要引用的项目即可。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前用eclipse做android开发的时候，一个工程项目引用的方式引用另一个工程，一直没有问题。今天为一个web工程引用另一个工程的时候，编译运行发生找不到“类”的错误。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
