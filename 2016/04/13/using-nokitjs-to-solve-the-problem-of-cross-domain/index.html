<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Houfeng"><meta name="description" content="问题在开发一些「单页应用」时，通常会使用Ajax和服务器通讯，比如RESTfulAPI，通常「前端」和「服务端API」可能是有不同人员在负责，也不在同一个工程下，那么开发过程中就可能会遇到跨域的问题，比如Chrome会在console中看到这样的错误消息:1X"><meta name="keywords" content=""><title>用 Nokitjs 解决前端开发中的跨域问题 · Houfeng's Blog</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="http://blog.houfeng.net/2016/04/13/using-nokitjs-to-solve-the-problem-of-cross-domain/"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3F16290d6dfe4977c6ba2d32fb7a483731";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script></head><body><div id="main"><header><a href="/." class="logo">Houfeng's Blog</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/about/" target="_self">About</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">用 Nokitjs 解决前端开发中的跨域问题</h1><span class="post-time">Apr 13, 2016</span><div id="sidebar" class="post-sidebar"><h3 class="heading">Contents</h3><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题"><span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见方法"><span class="toc-text">常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Access-Control-Allow-Origin"><span class="toc-text">1. Access-Control-Allow-Origin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-nginx-反向代理"><span class="toc-text">1. nginx 反向代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用-Nokitjs-解决问题"><span class="toc-text">用 Nokitjs 解决问题</span></a></li></ol></div><div class="post-content"><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在开发一些「单页应用」时，通常会使用 Ajax 和服务器通讯，比如 RESTful API，通常「前端」和「服务端 API」可能是有不同人员在负责，也不在同一个工程下，那么开发过程中就可能会遇到跨域的问题，比如 Chrome 会在 console 中看到这样的错误消息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">XMLHttpRequest cannot load http://google.com/. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://run.jsbin.io&apos; is therefore not allowed access.</div></pre></td></tr></table></figure>
<p>浏览器因为安全原因，有「同源策略」不允许「跨域」，有时也会给开发过程带来一点点小麻烦。</p>
<a id="more"></a>
<h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><h5 id="1-Access-Control-Allow-Origin"><a href="#1-Access-Control-Allow-Origin" class="headerlink" title="1. Access-Control-Allow-Origin"></a>1. Access-Control-Allow-Origin</h5><p>目前主流浏览器都支持，通过在服务器的响应头信息中添加 <strong>Access-Control-Allow-Origin</strong> 以声明允许来自那些「域」的跨域请求，比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: xxx.xyz</div></pre></td></tr></table></figure></p>
<p>也可以允许任何来源的跨域请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: *</div></pre></td></tr></table></figure></p>
<p>很少有场景必须要在「生产环境」使用 <em>，如果开发环境使用 </em>，那么在部署到生产环境时，为了安全启见，无论手动还是自动的方式，都需要换成「特定的域」</p>
<p>当然在开发环境也可指定特定的「域」，如上边的 xxx.xyz，那开发过程中就需要每个开发人员添加 host 配置，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">127.0.0.1 xxx.xyz</div></pre></td></tr></table></figure></p>
<h5 id="1-nginx-反向代理"><a href="#1-nginx-反向代理" class="headerlink" title="1. nginx 反向代理"></a>1. nginx 反向代理</h5><p>用代理的方式解决的跨域问题，就不要添加什么「响应头」了，用 nginx 搭建一个「用于开发」的 WebServer，然后，我们可以把某些 URL 转发到「目标地址」，然后前端用 ajax 请求同域下的地址，这样自然就不存在「跨域问题」了，nginx 配置大约如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">location /api/ &#123;</div><div class="line">    rewrite  ^/api/(.*)  /$1 break;</div><div class="line">    ...</div><div class="line">&#125; </div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>这个方式，需要让每个前端开发人员安装并配置 nginx，虽然可以正好学习 nginx，却还是稍显麻烦。</p>
<h3 id="用-Nokitjs-解决问题"><a href="#用-Nokitjs-解决问题" class="headerlink" title="用 Nokitjs 解决问题"></a>用 Nokitjs 解决问题</h3><p>Nokitjs 是一个「A Web development framework」，和 express/koa/hapi 等框架类似，用于开发「Web 应用或网站」，这里不去比较各个框架的优劣，而是去解决「跨域」问题。</p>
<p>Nokitjs 提供了「命令行工具」，在终端中直接使用「Nokit CLI」需要全局安装 Nokit:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install nokitjs -g</div></pre></td></tr></table></figure></p>
<p>Nokit CLI 一般用于启动「基于 Nokit 开发的应用」，同时它也能在「指定的目录」启动一个「静态 WebServer」，如下:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nokit start [端口] [应用目录省略时为当前目录] [其它选项]</div></pre></td></tr></table></figure></p>
<p>「其它选项」中有一个 <strong>-pulibc</strong> 选项，可以指定「静态资源目录」，如下命令，将在当前目录启一个「静态 WebServer」<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm start 8000 -public=./</div></pre></td></tr></table></figure></p>
<p>如何解决跨域问题？，还需要一个插件 <strong>nokit-filter-proxy</strong>，接下来用一个实例说明，假如我们有一个工程，结构如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">应用目录</div><div class="line">├── dist</div><div class="line">├── package.json</div><div class="line">└── src</div></pre></td></tr></table></figure></p>
<p><strong>dist</strong> 是「构建工具」Build 的目标目录，<strong>src</strong> 是源码目录，<strong>package.json</strong> 是 NPM 包配置文件。</p>
<p>安装 nokitjs 和 nokit-filter-proxy 并保存到 <strong>devDependencies</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">npm install nokitjs nokit-filter-proxy --save-dev</div><div class="line">``` </div><div class="line"></div><div class="line">配置 **package.json** 的 **scripts**，如下</div><div class="line">```json</div><div class="line">...</div><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">    &quot;start&quot;: &quot;nokit start 8000 -public=./dist&quot;,</div><div class="line">    &quot;stop&quot;: &quot;nokit stop&quot;,</div><div class="line">    &quot;restart&quot;: &quot;npm stop &amp;&amp; npm start&quot;,</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>现在，「不需要全局安装」 nokitjs，在「应用目录」执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm start</div></pre></td></tr></table></figure></p>
<p>即可启动一个「静态 WebServer」，将会看到如下提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[Nokit][L]: Starting...</div><div class="line">[Nokit][L]: The server on &quot;localhost:8000&quot; started</div></pre></td></tr></table></figure></p>
<p>就可以在浏览器中访问 <strong><a href="http://localhost:8000" target="_blank" rel="external">http://localhost:8000</a></strong> 了。</p>
<p>然后配置 <strong>nokit-filter-proxy</strong>，在「应用目录」新建一个文件 <strong>config.json</strong>，写入如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;filters&quot;: &#123;</div><div class="line">        &quot;^/&quot;: &quot;nokit-filter-proxy&quot;</div><div class="line">     &#125;,</div><div class="line">     &quot;proxy&quot;: &#123;</div><div class="line">        &quot;rules&quot;: &#123;</div><div class="line">          &quot;^/api/(.*)&quot;: &quot;http://xxx.xyz/&quot;</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上配置，首先注册了 <strong>nokit-filter-proxy</strong>，然后添加了一条转发规则，将所有 <strong>api</strong> 开头的 URL 转发到 <strong><a href="http://xxx.xyz" target="_blank" rel="external">http://xxx.xyz</a></strong>，比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET /api/user/id</div><div class="line">``` </div><div class="line"></div><div class="line">将会被转发到</div></pre></td></tr></table></figure></p>
<p>GET <a href="http://xxx.xyz/user/id" target="_blank" rel="external">http://xxx.xyz/user/id</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">可以添加任意多条转发规则，规则越靠后优化级越高。</div><div class="line"></div><div class="line">相比 nginx 省事不少，不需要每个开发人员再安装配置 nginx，可以在获取代码后，直接执行</div></pre></td></tr></table></figure></p>
<p>npm install<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">完成所有依赖的安装，然后便可以使用 **npm start** 启动 Server，并在浏览器中预览或调试了。</div><div class="line"></div><div class="line">另外，在启动时还可以通过 **config** 选项指定配置文件名，比如</div></pre></td></tr></table></figure></p>
<p>nokit start 8000 -public=./dist -config=webserver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这样，应用根目录的 **config.json** 就可以换成 **webserver.json** 了。</div><div class="line"></div><div class="line">或许，还希望不同的「环境」转发到不同的「地址」，又或者每个开发人员需要不同转发规则，可以通过 **--env** 指定不同的环境配置，也可以通过「系统环境变量 NODE_ENV」指定，如下</div></pre></td></tr></table></figure></p>
<p>nokit start 8000 -public=./dist -env=local<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">或</div></pre></td></tr></table></figure></p>
<p>export NODE_ENV=local<br>```</p>
<p>这样，在应用目录可以建立一个 <strong>config.local.json</strong> 文件，格式和 <strong>config.json</strong> 相同，nokit 会合并这两个文件，相同的配置节「环境配置文件」将覆盖「默认配置文件」的配置。</p>
<p>最后附上相关模块的 GitHub 地址:</p>
<ol>
<li>nokitjs <a href="https://github.com/nokitjs/nokit" target="_blank" rel="external">https://github.com/nokitjs/nokit</a></li>
<li>nokit-filter-proxy <a href="https://github.com/nokitjs/nokit-filter-proxy" target="_blank" rel="external">https://github.com/nokitjs/nokit-filter-proxy</a></li>
</ol>
</div></article><div class="tags"></div><div class="paginator"><a href="/2016/07/21/cize/" class="prev"><i class="iconfont icon-left"></i><span> Prev</span></a><a href="/2015/12/07/nokitjs/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div><section id="comments"><div data-thread-key="http://blog.houfeng.net/2016/04/13/using-nokitjs-to-solve-the-problem-of-cross-domain/index.html" data-title="用 Nokitjs 解决前端开发中的跨域问题" data-url="http://blog.houfeng.net/2016/04/13/using-nokitjs-to-solve-the-problem-of-cross-domain/index.html" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name: "houfeng" };
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></section></section><footer><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2009-2016<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Houfeng</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>