<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Houfeng"><meta name="description" content="###话题起因回头看自已写过东西，常会感觉到不满意，总有重构冲动（其实这种冲动通常是好事，因为只有发现了不足才有重构想法，只有重构才能改进，只有改进才能完善）。"><meta name="keywords" content=""><title>模块的封装与解耦 · Houfeng's Blog</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="http://blog.houfeng.net/2016/08/27/2013-03-16-module-encapsulation-decoupling/"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3F16290d6dfe4977c6ba2d32fb7a483731";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script></head><body><div id="main"><header><a href="/." class="logo">Houfeng's Blog</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/about/" target="_self">About</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">模块的封装与解耦</h1><span class="post-time">Aug 27, 2016</span><div class="post-content"><p>###话题起因<br>回头看自已写过东西，常会感觉到不满意，总有重构冲动（其实这种冲动通常是好事，因为只有发现了不足才有重构想法，只有重构才能改进，只有改进才能完善）。</p>
<a id="more"></a>
<p>最近，准备重构<a href="http://houfeng/mokit" target="_blank" rel="external">mokit</a>，因为这前的mokit虽然有将不同的“模块”分离在不同的文件中，并有“命名空间”概念，但其实现在版本的mokit模块甚至不能称为真正的模块，因为它没有完整“封装”的概念，并且虽有“命名空间”，但还是会创建一部分全局变量，只能依靠开发人员制定好的“契约”，既“非强制约束”的开发规范。</p>
<p>因为现有mokit存在的各种不足，在重构之前一直在思考mokit更合适的结构：</p>
<ol>
<li>更加清析的、真正的模块化的结构；</li>
<li>模块的真正封装；</li>
<li>模块间的最大化解耦；</li>
<li>更加清析的MVC或MVP模式；</li>
</ol>
<p>第一步先实现真的模块封装，及模块中的解耦，第二步实现简洁易用的MVC或MVP的架构及开框架。MVC稍后再谈，这篇博文将就模块化、封装、解耦做一些控讨。</p>
<p>###模块的封装</p>
<p>#####百度百科:<br>模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性<br>模块化是一种处理复杂系统分解为更好的可管理模块的方式。</p>
<p>模块化用来分割，组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能。<br>模块具有以下几种基本属性：接口、功能、逻辑、状态，功能、状态与接口反映模块的外部特性，逻辑反映它的内部特性。<br>在系统的结构中，模块是可组合、分解和更换的单元。模块化是一种处理复杂系统分解成为更好的可管理模块的方式。它可以通过在不同组件设定不同的功能，把一个问题分解成多个小的独立、互相作用的组件，来处理复杂、大型的软件。</p>
<p>#####实现模块封装:<br>在完整面向对象的语言中可能是一个类，封装作为OOP三大特性：封装、多态、继承之一，在这些有完整OOP机制的语言实现模块的封装非常容易</p>
<p>如在C#中</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">string</span> Ident&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在C#中，一个类（模块）可以方便的声明“私有成员”，实现封装特性；</p>
<p>而在JavaScript中实现就稍显“麻烦”，而且写法是各种各样，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Module1=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> ident=<span class="string">""</span>;</div><div class="line">	<span class="keyword">var</span> name=<span class="string">""</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">    	getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        	<span class="keyword">return</span> name;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>上边在JavaScript的自执行函数中，通过var定议的变量，在函数外部不能被访问也实现了封装。<br>事实上，JavaScript的有很多模块化的库，能够实现更加完整的模块定义，如RequireJS、EmsJs。</p>
<p>###模块的依赖<br>当程序采用模块化的结构后，不同的功能都分布在不同的模块中，必然存在模块相互调用的问题，这时就需要管理好模块之间的依赖关系；</p>
<p>依赖常常表直观的表现为：</p>
<ol>
<li>在一个包中import另一个包；</li>
<li>在一个类中调用另一个类或存在加一个类的引用；</li>
<li>在一个js文件中用别一个js文件中定议的对象或函数；</li>
</ol>
<p>如在C#中：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> calss A</div><div class="line">&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span> A _a=<span class="keyword">new</span> A();</div><div class="line">	<span class="keyword">public</span> A a</div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">get</span></div><div class="line">        &#123;</div><div class="line">        	<span class="keyword">return</span> _a;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上代码类“B”事实上对类“A”存在“依赖”，在没有A的时候，B是不完整的，是无法使用的；当要替换A的时候需重新编写B，这样其实A、B之间的“耦合”非常高。</p>
<p>这里是假设每一个类就是一个模块，其实，上有时模块的粒度不能到一个类一个模块，我们也不需要每一个类都要“解耦”，但是上边的示例代码，却能“高耦合”的代码带的的问题；</p>
<p>我曾见过一定情况下很“二”的写法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IA</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span> : <span class="title">IA</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span> IA _a=<span class="keyword">new</span> A();</div><div class="line">	<span class="keyword">public</span> IA a</div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">get</span></div><div class="line">        &#123;</div><div class="line">        	<span class="keyword">return</span> _a;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span>&#123;</div><div class="line">        	_a=<span class="keyword">value</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，或许写代码的人一定是想用interface实现A、B间的“解耦”，实际上还不到位，B对A的依赖依然存在，没有任何意义；</p>
<p>###模块间的解耦</p>
<p>#####依赖反转:<br>在面向对象编程领域中，依赖反转原则（Dependency inversion principle）指代了一种特定的解耦（传统的依赖关系建立在高层次上，而具体的策略设置则应用在低层次的模块上）形式。在这种形势下，为了使得高层次的模块不依赖于低层次的模块的实现细节的目的，依赖模块被颠倒了（例如：反转）。该原则规定：<br>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。<br>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。<br>该原则颠倒了一部分人对于面向对象设计的认识方式，比如高层次和低层次对象都应该应该依赖于相同的抽象接口</p>
<p>改掉这很“二”的写法，如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IA</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span> : <span class="title">IA</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span> IA _a=<span class="literal">null</span>;</div><div class="line">	<span class="keyword">public</span> IA a</div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">get</span></div><div class="line">        &#123;</div><div class="line">        	<span class="keyword">if</span>(_a==<span class="literal">null</span>)</div><div class="line">            &#123;</div><div class="line">            	<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"IA没有找到"</span>);</div><div class="line">            &#125;</div><div class="line">        	<span class="keyword">return</span> _a;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span>&#123;</div><div class="line">        	_a=<span class="keyword">value</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这B、A没有强制依赖了，在更换A的时间，也无须动B中的代码，或许我们是用B前的某一个地主将IA的一个实现类实例传给了B，也有可能是基于配置文件及“反射”完成的。</p>
<p>比如，一个插件式的应用程序！</p>
</div></article><div class="tags"></div><div class="paginator"><a href="/2016/08/27/2013-01-24-Adobe-Web-HTML5/" class="prev"><i class="iconfont icon-left"></i><span> Prev</span></a><a href="/2016/08/27/2013-10-26-mongodb-replica-set/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div><section id="comments"><div data-thread-key="http://blog.houfeng.net/2016/08/27/2013-03-16-module-encapsulation-decoupling/index.html" data-title="模块的封装与解耦" data-url="http://blog.houfeng.net/2016/08/27/2013-03-16-module-encapsulation-decoupling/index.html" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name: "houfeng" };
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></section></section><footer><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2009-2016<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Houfeng</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>