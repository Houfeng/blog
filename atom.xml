<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Houfeng&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.houfeng.net/"/>
  <updated>2016-08-27T04:45:49.000Z</updated>
  <id>http://blog.houfeng.net/</id>
  
  <author>
    <name>Houfeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Confman - 针对「Node 应用」的配置文件加载模块</title>
    <link href="http://blog.houfeng.net/2016/07/29/confman/"/>
    <id>http://blog.houfeng.net/2016/07/29/confman/</id>
    <published>2016-07-28T16:00:00.000Z</published>
    <updated>2016-08-27T04:45:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一句话介绍"><a href="#一句话介绍" class="headerlink" title="一句话介绍"></a>一句话介绍</h1><p>Confman 是一个强大的配置文件加载器，无论你喜欢 yaml 、cson、json、properties、plist、ini、toml、xml 还是 js，都能满足你的愿望，并且更加简单、更加强大。</p>
<p><a href="http://badge.fury.io/js/confman" target="_blank" rel="external"><img src="https://badge.fury.io/js/confman.svg" alt="npm version"></a> <a href="https://travis-ci.org/Houfeng/confman" target="_blank" rel="external"><img src="https://travis-ci.org/Houfeng/confman.svg?branch=master" alt="Build Status"></a> </p>
<a id="more"></a>
<h1 id="支持的特性"><a href="#支持的特性" class="headerlink" title="支持的特性"></a>支持的特性</h1><ul>
<li>支持多种配置文件格式，默认包括 yaml/cson/json/properties/plist/ini/toml/xml/js </li>
<li>支持配置文件相互引用，无论何种格式都可以「引用其它任意格式」的配置文件</li>
<li>支持「基于目录」的多文件配置</li>
<li>支持「环境配置」，区分加载生产、测试等不同的配置</li>
<li>可以非常方便的「扩展」新的配置文件格式</li>
<li>可以「混合使用」不同的配置文件格式</li>
<li>内置多种「指令」，并可轻易的扩展新的指令</li>
</ul>
<h1 id="现在就安装"><a href="#现在就安装" class="headerlink" title="现在就安装"></a>现在就安装</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install confman --save</div></pre></td></tr></table></figure>
<h1 id="来几个示例"><a href="#来几个示例" class="headerlink" title="来几个示例"></a>来几个示例</h1><h4 id="不同的环境配置"><a href="#不同的环境配置" class="headerlink" title="不同的环境配置"></a>不同的环境配置</h4><p>目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">app</div><div class="line">├── index.js</div><div class="line">├── config.dev.yaml</div><div class="line">├── config.prod.yaml</div><div class="line">└── config.yaml</div></pre></td></tr></table></figure></p>
<p>index.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> confman = <span class="built_in">require</span>(<span class="string">'confman'</span>);</div><div class="line"><span class="keyword">const</span> configs = confman.load(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/config`</span>);</div><div class="line"><span class="built_in">console</span>.log(configs);</div></pre></td></tr></table></figure></p>
<p>启动应用<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ NODE_ENV=prod node index.js</div></pre></td></tr></table></figure></p>
<p>通过指定 <figure class="highlight plain"><figcaption><span>可以加载指定的「环境配置文件 config.prod.yaml」，并和「默认配置 config.yaml」进行合并,</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">如果有相同的配置，「环境配置会覆盖默认配置」</div><div class="line"></div><div class="line">#### 配置文件相互引用</div><div class="line">文件一: test1.yaml</div><div class="line">```yaml</div><div class="line">name: test1</div><div class="line">#可以使用 $require 引用其它文件</div><div class="line">child: $requrie ./test2</div></pre></td></tr></table></figure></p>
<p>文件二: test2.json<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"test2"</span>,</div><div class="line">   <span class="attr">"child"</span>: <span class="string">"$require other-file"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>可以在任意支持的格式的配置文件中使用</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 基于目录的多文件配置</div><div class="line">目录结构</div></pre></td></tr></table></figure>
<p>├── config<br>│   ├── conn.yaml<br>│   ├── index.yaml<br>│   └── mvc.yaml<br>├── config.dev<br>│   └── conn.yaml<br>├── config.prod<br>│   └── conn.yaml<br>└── index.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">index.js</div><div class="line">```js</div><div class="line">const confman = require(&apos;confman&apos;);</div><div class="line">const configs = confman.load(`$&#123;__dirname&#125;/config`);</div><div class="line">console.log(configs);</div></pre></td></tr></table></figure></p>
<h1 id="添加新格式"><a href="#添加新格式" class="headerlink" title="添加新格式"></a>添加新格式</h1><p>其实，多数情况你不需要这么做，如果确实有需要，你可这样编写一个自定义 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```js</div><div class="line">module.exports = &#123;</div><div class="line">  extname: &apos;.xxx&apos;,</div><div class="line">  load: function (configPath) &#123;</div><div class="line">    //...</div><div class="line">    return configs;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>注册自定义 loader<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">confman.loaders.push(<span class="built_in">require</span>(<span class="string">'your-loader-path'</span>));</div></pre></td></tr></table></figure></p>
<h1 id="新的扩展名"><a href="#新的扩展名" class="headerlink" title="新的扩展名"></a>新的扩展名</h1><p>方式一，映射到一个已经添加的 loader<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">confman.loaders.push(&#123;</div><div class="line">  extname: <span class="string">'.xxx'</span>,</div><div class="line">  loader: <span class="string">'.yaml'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>方式二，直接映射到一个未添加的自定义 loader<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">confman.loaders.push(&#123;</div><div class="line">  extname: <span class="string">'.xxx'</span>,</div><div class="line">  loader: <span class="built_in">require</span>(<span class="string">'your-loader-path'</span>)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="内置的指令"><a href="#内置的指令" class="headerlink" title="内置的指令"></a>内置的指令</h1><p>如上边用到的 <figure class="highlight plain"><figcaption><span>允许使用指令完成某些配置，内置的指令包括:</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- $require 引用指令，用于引用其它配置文件，参数为相对于当前文件的相对路径或绝对路径</div><div class="line">- $calc 计算指令，用于计算一个表达式，如 $calc root.baseUrl+&quot;/xxx&quot; (表达式中可用变量有 root:根对象，parent:父对象，self:当前对象)</div><div class="line">- $read 读取指令，用于读取一个文本文件，参数为相对于当前文件的相对路径或绝对路径</div><div class="line"></div><div class="line">示例 example.yaml</div><div class="line">```yaml</div><div class="line">name: example</div><div class="line">test1: $require ./test1.json</div><div class="line">test2: $read ./test2.txt</div><div class="line">test3: $calc root.name + &quot;:test3&quot;</div></pre></td></tr></table></figure></p>
<p>假如 <figure class="highlight plain"><figcaption><span>的内容为 ```&#123; "name": "test1" &#125;```，```test2.txt``` 的内容为 ```my name is test2```,</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">通过 ```Confman.load(&apos;./example&apos;)``` 加载 ```example``` 的结果为：</div><div class="line"></div><div class="line">```json</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;example&quot;,</div><div class="line">  &quot;test1&quot;: &#123; &quot;name&quot;: &quot;test1&quot; &#125;,</div><div class="line">  &quot;test2&quot;: &quot;my name is test2&quot;,</div><div class="line">  &quot;test3&quot;: &quot;example:test3&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><p>编写一个自定义指令的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  name: <span class="string">'xxx'</span>,</div><div class="line">  exec: <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</div><div class="line">    <span class="comment">//context.fromPath 来自哪个配置文件</span></div><div class="line">    <span class="comment">//context.parser 当前 Confman 实例</span></div><div class="line">    <span class="comment">//context.root 根对象</span></div><div class="line">    <span class="comment">//context.parent 父对象</span></div><div class="line">    <span class="comment">//context.self 当前对象</span></div><div class="line">    <span class="comment">//context.name 配置属性名</span></div><div class="line">    <span class="comment">//context.value 指令后的值</span></div><div class="line">    <span class="keyword">return</span> &#123;&#125; <span class="comment">//返回值为指令执行结果</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注册自定义指令<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">confman.directives.push(<span class="built_in">require</span>(<span class="string">'your_directive_path'</span>));</div></pre></td></tr></table></figure></p>
<h1 id="其它的问题"><a href="#其它的问题" class="headerlink" title="其它的问题"></a>其它的问题</h1><ul>
<li>新的建议或 Bug 请使用 isseus 反馈</li>
<li>贡献代码，请使用 Pull Request，需一并提交相关测试并且不能低于现有覆盖率</li>
</ul>
<blockquote>
<p>现在或将来有可能会用到？那你应该去加个 Star<br>GitHub : <a href="https://github.com/Houfeng/confman" target="_blank" rel="external">https://github.com/Houfeng/confman</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一句话介绍&quot;&gt;&lt;a href=&quot;#一句话介绍&quot; class=&quot;headerlink&quot; title=&quot;一句话介绍&quot;&gt;&lt;/a&gt;一句话介绍&lt;/h1&gt;&lt;p&gt;Confman 是一个强大的配置文件加载器，无论你喜欢 yaml 、cson、json、properties、plist、ini、toml、xml 还是 js，都能满足你的愿望，并且更加简单、更加强大。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://badge.fury.io/js/confman&quot;&gt;&lt;img src=&quot;https://badge.fury.io/js/confman.svg&quot; alt=&quot;npm version&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://travis-ci.org/Houfeng/confman&quot;&gt;&lt;img src=&quot;https://travis-ci.org/Houfeng/confman.svg?branch=master&quot; alt=&quot;Build Status&quot;&gt;&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>基于 Node.js 的轻量「持续集成」工具 CIZE</title>
    <link href="http://blog.houfeng.net/2016/07/21/cize/"/>
    <id>http://blog.houfeng.net/2016/07/21/cize/</id>
    <published>2016-07-20T16:00:00.000Z</published>
    <updated>2016-08-27T04:43:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CIZE-是什么？"><a href="#CIZE-是什么？" class="headerlink" title="CIZE 是什么？"></a>CIZE 是什么？</h2><p>CIZE 是一个「持续集成」工具，希望能让开发人员更快捷的搭建一个完整、可靠、便捷的 CI 服务。<br>甚至可以像 Gulp 或 Grunt 一样，仅仅通过一个 cizefile.js 即可完成几乎所有的工作。</p>
<blockquote>
<p>如果您对它有一点兴趣，欢迎到 GitHub 加个 star 以关注它。<br><a href="https://github.com/Houfeng/cize" target="_blank" rel="external">https://github.com/Houfeng/cize</a></p>
</blockquote>
<a id="more"></a>
<p><a href="http://badge.fury.io/js/cize" target="_blank" rel="external"><img src="https://badge.fury.io/js/cize.svg" alt="npm version"></a><a href="https://travis-ci.org/Houfeng/cize" target="_blank" rel="external"><img src="https://travis-ci.org/Houfeng/cize.svg?branch=master" alt="Build Status"></a> </p>
<p><img src="https://raw.githubusercontent.com/houfeng/cize/master/screenshot/monitor.png" alt="https://raw.githubusercontent.com/houfeng/cize/master/screenshot/monitor.png"></p>
<h2 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h2><h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ [sudo] npm install cize -g</div></pre></td></tr></table></figure>
<h3 id="编写-Job"><a href="#编写-Job" class="headerlink" title="编写 Job"></a>编写 Job</h3><p>新建 cizefile.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mkdir your_path</div><div class="line">$ cd your_path</div><div class="line">$ vim cizefile.js</div></pre></td></tr></table></figure></p>
<p>输入如下内容<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义「项目」</span></div><div class="line"><span class="keyword">const</span> demo = cize.project(<span class="string">'demo'</span>, &#123;&#125;);</div><div class="line"></div><div class="line"><span class="comment">//定义一个 Job，这是一个最基础的 Job</span></div><div class="line">demo.job(<span class="string">'hello'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">self</span>) </span>&#123;</div><div class="line">  self.console.log(<span class="string">'hello world'</span>);</div><div class="line">  self.done();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>然后，在「工作目录」中执行 <figure class="highlight plain"><figcaption><span>启动服务</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>$ cize<br>Strarting…<br>The server on “localhost:9000” started<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">默认会启动和 CPU 核数相同的「工作进程」。</div><div class="line"></div><div class="line">接下来，可以在浏览器中访问 ```http://localhost:9000```，并可以在 UI 中手动触发这个名为 ```hello``` 的 Job。</div><div class="line"></div><div class="line">## 定义 Project</div><div class="line">```js</div><div class="line">const demo = cize.project(&apos;demo&apos;, &#123;</div><div class="line">  ...</div><div class="line">  //可以在此添加针对项目的配置</div><div class="line">  ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>注意，即便一个项目不需要任何配置，也不能省略第二个参数，没有第二个参数时 <figure class="highlight plain"><figcaption><span>为获取指定的项目。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 定义 Job</div><div class="line">假定现在已经有一个定义好的名为 ```demo``` 的 ```project``` </div><div class="line"></div><div class="line">### 用 js 编写的 Job</div><div class="line">```js</div><div class="line">demo.job(&apos;test&apos;, function (self) &#123;</div><div class="line">  self.console.log(&apos;test&apos;);</div><div class="line">  self.done();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这是最基础的 Job 类型，是其它 Job 类型或「扩展」的基础。</p>
<h3 id="用-shell-编写的-Job"><a href="#用-shell-编写的-Job" class="headerlink" title="用 shell 编写的 Job"></a>用 shell 编写的 Job</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">demo.job(<span class="string">'test'</span>, cize.shell(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">/*</span></div><div class="line">    echo "hello world"</div><div class="line">  */</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>定义一个用 SHELL 编写的 Job，用到了 cize.shell，这是一个「内置扩展」。</p>
<h3 id="定时执行的-Job"><a href="#定时执行的-Job" class="headerlink" title="定时执行的 Job"></a>定时执行的 Job</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">demo.job(<span class="string">'test'</span>, cize.cron(<span class="string">'* */2 * * * *'</span>, cize.shell(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">/*</span></div><div class="line">    echo "hello world"</div><div class="line">  */</div><div class="line">&#125;)));</div></pre></td></tr></table></figure>
<p>如上定义了一个每两分种触发一次的 Job 并且，嵌套使用了 shell.</p>
<h3 id="监听其它-Job-的-Job"><a href="#监听其它-Job-的-Job" class="headerlink" title="监听其它 Job 的 Job"></a>监听其它 Job 的 Job</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">demo.job(<span class="string">'test2'</span>, cize.by(<span class="string">'test1'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">self</span>)</span>&#123;</div><div class="line">  self.console.log(<span class="string">'hello'</span>);</div><div class="line">  self.done();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如下，在 test1 执行成功后，将会触发 test2</p>
<h3 id="串行执行的-Job"><a href="#串行执行的-Job" class="headerlink" title="串行执行的 Job"></a>串行执行的 Job</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">demo.job(<span class="string">'test'</span>, cize.series([</div><div class="line">  <span class="string">"test1"</span>,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">self</span>)</span>&#123;</div><div class="line">    self.console.log(<span class="string">'hello'</span>);</div><div class="line">    self.done();</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"test3"</span></div><div class="line">]));</div></pre></td></tr></table></figure>
<p>series 是一个内置扩展，可以定义一个「串行执行」多个步骤的任务列表，每个步骤可以是一个任意类型的 job，<br>也可以是指定要调用的其它 Job 的名称。</p>
<h3 id="并行执行的-Job"><a href="#并行执行的-Job" class="headerlink" title="并行执行的 Job"></a>并行执行的 Job</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">demo.job(<span class="string">'test'</span>, cize.parallel([</div><div class="line">  <span class="string">"test1"</span>,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">self</span>)</span>&#123;</div><div class="line">    self.console.log(<span class="string">'hello'</span>);</div><div class="line">    self.done();</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"test3"</span></div><div class="line">]));</div></pre></td></tr></table></figure>
<p>series 是一个内置扩展，可以定义一个「并行执行」多个步骤的任务列表，每个步骤可以是一个任意类型的 job，<br>也可以是指定要调用的其它 Job 的名称。</p>
<h3 id="多步嵌套的-Job"><a href="#多步嵌套的-Job" class="headerlink" title="多步嵌套的 Job"></a>多步嵌套的 Job</h3><p>CIZE 所有的 Job 可以自由嵌套，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">demo.job(<span class="string">'test'</span>, cize.parallel([</div><div class="line">  <span class="string">"test1"</span>,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">self</span>)</span>&#123;</div><div class="line">    self.console.log(<span class="string">'hello'</span>);</div><div class="line">    self.done();</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"test3"</span>,</div><div class="line">  cize.series([</div><div class="line">    <span class="string">"test4"</span>,</div><div class="line">    cize.shell(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="comment">/*</span></div><div class="line">        echo hello</div><div class="line">      */</div><div class="line">    &#125;)</div><div class="line">  ])</div><div class="line">]));</div></pre></td></tr></table></figure></p>
<p>当你使用一个「外部扩展」时，也可以混合使用。</p>
<h2 id="编写一个扩展"><a href="#编写一个扩展" class="headerlink" title="编写一个扩展"></a>编写一个扩展</h2><p>如上用到的 cize.shell、cize.series、cize。parallel、cize.cron、cize.by 是 cize 默契认包含的「内置扩展」。</p>
<p>编写一个「外部扩展」和「内置扩展」并无本质区别，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">options...</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">self</span>)</span>&#123;</div><div class="line">    <span class="comment">//处理逻辑</span></div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如查需要在 Job 定义时进行一些处理，可以使用 <figure class="highlight plain"><figcaption><span>，如下</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">```js</div><div class="line">module.exports = function(options...)&#123;</div><div class="line">  return &#123;</div><div class="line">    register: function(Job)&#123;</div><div class="line">      //Job 是你的「自定义 Job 类型」</div><div class="line">      //注册时逻辑</div><div class="line">    &#125;,</div><div class="line">    runable: function(self)&#123;</div><div class="line">      //执行时逻辑</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可以将扩展发布为一个「npm 包」，让更多的人使用。</p>
<h2 id="服务选项"><a href="#服务选项" class="headerlink" title="服务选项"></a>服务选项</h2><p>可以通过一些选择去控制 CI 服务的端口、密钥等，有两种方式，如下</p>
<h3 id="在-cizefile-js-中配置"><a href="#在-cizefile-js-中配置" class="headerlink" title="在 cizefile.js 中配置"></a>在 cizefile.js 中配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cize.config(&#123;</div><div class="line">  port: <span class="number">9000</span>,</div><div class="line">  secret: <span class="string">'12345'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="通过命令行工具"><a href="#通过命令行工具" class="headerlink" title="通过命令行工具"></a>通过命令行工具</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cize ./ -p=port -s=secret</div></pre></td></tr></table></figure>
<p>通过 cize -h 可以查看完整的说明<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line">  cize [folder|file] [options]</div><div class="line"></div><div class="line">Options:</div><div class="line">  -w   <span class="built_in">set</span> the number of workers</div><div class="line">  -p   <span class="built_in">set</span> the port</div><div class="line">  <span class="_">-s</span>   <span class="built_in">set</span> the secret</div><div class="line">  -h   display <span class="built_in">help</span> information</div><div class="line"></div><div class="line">Example:</div><div class="line">  cize ./ -p=9000 <span class="_">-s</span>=12345 -w=4</div></pre></td></tr></table></figure></p>
<h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><p>请访问 wiki: <a href="https://github.com/Houfeng/cize/wiki" target="_blank" rel="external">https://github.com/Houfeng/cize/wiki</a></p>
<blockquote>
<p>如果您对它有一点问题或建议，请到 GitHub 通过 issue 提出您的疑问或建议。 <a href="https://github.com/Houfeng/cize-gitlab/issues" target="_blank" rel="external">https://github.com/Houfeng/cize-gitlab/issues</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CIZE-是什么？&quot;&gt;&lt;a href=&quot;#CIZE-是什么？&quot; class=&quot;headerlink&quot; title=&quot;CIZE 是什么？&quot;&gt;&lt;/a&gt;CIZE 是什么？&lt;/h2&gt;&lt;p&gt;CIZE 是一个「持续集成」工具，希望能让开发人员更快捷的搭建一个完整、可靠、便捷的 CI 服务。&lt;br&gt;甚至可以像 Gulp 或 Grunt 一样，仅仅通过一个 cizefile.js 即可完成几乎所有的工作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果您对它有一点兴趣，欢迎到 GitHub 加个 star 以关注它。&lt;br&gt;&lt;a href=&quot;https://github.com/Houfeng/cize&quot;&gt;https://github.com/Houfeng/cize&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>用 Nokitjs 解决前端开发中的跨域问题</title>
    <link href="http://blog.houfeng.net/2016/04/13/using-nokitjs-to-solve-the-problem-of-cross-domain/"/>
    <id>http://blog.houfeng.net/2016/04/13/using-nokitjs-to-solve-the-problem-of-cross-domain/</id>
    <published>2016-04-12T16:00:00.000Z</published>
    <updated>2016-08-27T04:44:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在开发一些「单页应用」时，通常会使用 Ajax 和服务器通讯，比如 RESTful API，通常「前端」和「服务端 API」可能是有不同人员在负责，也不在同一个工程下，那么开发过程中就可能会遇到跨域的问题，比如 Chrome 会在 console 中看到这样的错误消息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">XMLHttpRequest cannot load http://google.com/. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://run.jsbin.io&apos; is therefore not allowed access.</div></pre></td></tr></table></figure>
<p>浏览器因为安全原因，有「同源策略」不允许「跨域」，有时也会给开发过程带来一点点小麻烦。</p>
<a id="more"></a>
<h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><h5 id="1-Access-Control-Allow-Origin"><a href="#1-Access-Control-Allow-Origin" class="headerlink" title="1. Access-Control-Allow-Origin"></a>1. Access-Control-Allow-Origin</h5><p>目前主流浏览器都支持，通过在服务器的响应头信息中添加 <figure class="highlight plain"><figcaption><span>以声明允许来自那些「域」的跨域请求，比如:</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">Access-Control-Allow-Origin: xxx.xyz</div></pre></td></tr></table></figure></p>
<p>也可以允许任何来源的跨域请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: *</div></pre></td></tr></table></figure></p>
<p>很少有场景必须要在「生产环境」使用 <figure class="highlight plain"><figcaption><span>```*```，那么在部署到生产环境时，为了安全启见，无论手动还是自动的方式，都需要换成「特定的域」</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当然在开发环境也可指定特定的「域」，如上边的 ```xxx.xyz```，那开发过程中就需要每个开发人员添加 ```host``` 配置，如下:</div></pre></td></tr></table></figure></p>
<p>127.0.0.1 xxx.xyz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 1. nginx 反向代理</div><div class="line">用代理的方式解决的跨域问题，就不要添加什么「响应头」了，用 nginx 搭建一个「用于开发」的 WebServer，然后，我们可以把某些 URL 转发到「目标地址」，然后前端用 ajax 请求同域下的地址，这样自然就不存在「跨域问题」了，nginx 配置大约如下：</div></pre></td></tr></table></figure></p>
<p>…<br>location /api/ {<br>    rewrite  ^/api/(.*)  /$1 break;<br>    …<br>}<br>…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这个方式，需要让每个前端开发人员安装并配置 nginx，虽然可以正好学习 nginx，却还是稍显麻烦。</div><div class="line"></div><div class="line">### 用 Nokitjs 解决问题 </div><div class="line">Nokitjs 是一个「A Web development framework」，和 express/koa/hapi 等框架类似，用于开发「Web 应用或网站」，这里不去比较各个框架的优劣，而是去解决「跨域」问题。</div><div class="line"></div><div class="line">Nokitjs 提供了「命令行工具」，在终端中直接使用「Nokit CLI」需要全局安装 Nokit:</div><div class="line">```sh</div><div class="line">npm install nokitjs -g</div></pre></td></tr></table></figure></p>
<p>Nokit CLI 一般用于启动「基于 Nokit 开发的应用」，同时它也能在「指定的目录」启动一个「静态 WebServer」，如下:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nokit start [端口] [应用目录省略时为当前目录] [其它选项]</div></pre></td></tr></table></figure></p>
<p>「其它选项」中有一个 <figure class="highlight plain"><figcaption><span>选项，可以指定「静态资源目录」，如下命令，将在当前目录启一个「静态 WebServer」</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```sh</div><div class="line">npm start 8000 -public=./</div></pre></td></tr></table></figure></p>
<p>如何解决跨域问题？，还需要一个插件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">应用目录</div><div class="line">├── dist</div><div class="line">├── package.json</div><div class="line">└── src</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>是「构建工具」Build 的目标目录，```src``` 是源码目录，```package.json``` 是 NPM 包配置文件。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">安装 nokitjs 和 nokit-filter-proxy 并保存到 ```devDependencies</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">npm install nokitjs nokit-filter-proxy --save-dev</div><div class="line">``` </div><div class="line"></div><div class="line">配置 ```package.json``` 的 ```scripts```，如下</div><div class="line">```json</div><div class="line">...</div><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">    &quot;start&quot;: &quot;nokit start 8000 -public=./dist&quot;,</div><div class="line">    &quot;stop&quot;: &quot;nokit stop&quot;,</div><div class="line">    &quot;restart&quot;: &quot;npm stop &amp;&amp; npm start&quot;,</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>现在，「不需要全局安装」 nokitjs，在「应用目录」执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm start</div></pre></td></tr></table></figure></p>
<p>即可启动一个「静态 WebServer」，将会看到如下提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[Nokit][L]: Starting...</div><div class="line">[Nokit][L]: The server on &quot;localhost:8000&quot; started</div></pre></td></tr></table></figure></p>
<p>就可以在浏览器中访问 <figure class="highlight plain"><figcaption><span>了。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后配置 ```nokit-filter-proxy```，在「应用目录」新建一个文件 ```config.json```，写入如下内容：</div></pre></td></tr></table></figure></p>
<p>{<br>    “filters”: {<br>        “^/“: “nokit-filter-proxy”<br>     },<br>     “proxy”: {<br>        “rules”: {<br>          “^/api/(.*)”: “<a href="http://xxx.xyz/" target="_blank" rel="external">http://xxx.xyz/</a>“<br>        }<br>     }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如上配置，首先注册了 ```nokit-filter-proxy```，然后添加了一条转发规则，将所有 ```/api``` 开头的 URL 转发到 ```http://xxx.xyz/```，比如:</div></pre></td></tr></table></figure></p>
<p>GET /api/user/id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">将会被转发到</div></pre></td></tr></table></figure></p>
<p>GET <a href="http://xxx.xyz/user/id" target="_blank" rel="external">http://xxx.xyz/user/id</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">可以添加任意多条转发规则，规则越靠后优化级越高。</div><div class="line"></div><div class="line">相比 nginx 省事不少，不需要每个开发人员再安装配置 nginx，可以在获取代码后，直接执行</div></pre></td></tr></table></figure></p>
<p>npm install<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">完成所有依赖的安装，然后便可以使用 ```npm start``` 启动 Server，并在浏览器中预览或调试了。</div><div class="line"></div><div class="line">另外，在启动时还可以通过 ```-config``` 选项指定配置文件名，比如</div></pre></td></tr></table></figure></p>
<p>nokit start 8000 -public=./dist -config=webserver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这样，应用根目录的 ```config.json``` 就可以换成 ```webserver.json``` 了。</div><div class="line"></div><div class="line">或许，还希望不同的「环境」转发到不同的「地址」，又或者每个开发人员需要不同转发规则，可以通过 ```-env``` 指定不同的环境配置，也可以通过「系统环境变量 NODE_ENV」指定，如下</div></pre></td></tr></table></figure></p>
<p>nokit start 8000 -public=./dist -env=local<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">或</div></pre></td></tr></table></figure></p>
<p>export NODE_ENV=local<br>```</p>
<p>这样，在应用目录可以建立一个 <code>config.local.json</code> 文件，格式和 <code>config.json</code> 相同，nokit 会合并这两个文件，相同的配置节「环境配置文件」将覆盖「默认配置文件」的配置。</p>
<p>最后附上相关模块的 GitHub 地址:</p>
<ol>
<li>nokitjs <a href="https://github.com/nokitjs/nokit" target="_blank" rel="external">https://github.com/nokitjs/nokit</a></li>
<li>nokit-filter-proxy <a href="https://github.com/nokitjs/nokit-filter-proxy" target="_blank" rel="external">https://github.com/nokitjs/nokit-filter-proxy</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;在开发一些「单页应用」时，通常会使用 Ajax 和服务器通讯，比如 RESTful API，通常「前端」和「服务端 API」可能是有不同人员在负责，也不在同一个工程下，那么开发过程中就可能会遇到跨域的问题，比如 Chrome 会在 console 中看到这样的错误消息:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;XMLHttpRequest cannot load http://google.com/. No &amp;apos;Access-Control-Allow-Origin&amp;apos; header is present on the requested resource. Origin &amp;apos;http://run.jsbin.io&amp;apos; is therefore not allowed access.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;浏览器因为安全原因，有「同源策略」不允许「跨域」，有时也会给开发过程带来一点点小麻烦。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>一个基于 Node.js 的 Web 开发框架 - Nokitjs</title>
    <link href="http://blog.houfeng.net/2015/12/07/nokitjs/"/>
    <id>http://blog.houfeng.net/2015/12/07/nokitjs/</id>
    <published>2015-12-06T16:00:00.000Z</published>
    <updated>2016-08-27T04:39:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Nokit 是一个简单易用的基于 Nodejs 的 Web 开发框架，默认提供了 MVC / NSP / RESTful 等支持，并提供对应项目模板、管理工具。</p>
<a id="more"></a>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><blockquote>
<ul>
<li>GitHub <a href="https://github.com/nokitjs/nokit" target="_blank" rel="external">https://github.com/nokitjs/nokit</a> (<figure class="highlight plain"><figcaption><span>star```)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; - 使用说明 [wiki](https://github.com/nokitjs/nokit/wiki)</div><div class="line">&gt; - 问题反馈 [issues](https://github.com/nokitjs/nokit/issues)</div><div class="line">&gt; - 主页 [http://nokit.org](http://nokit.org)</div><div class="line"></div><div class="line">## 安装和更新</div><div class="line"></div><div class="line">#### 安装 nokit</div><div class="line">```sh</div><div class="line">[sudo] npm install nokitjs [-g]</div></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h4 id="更新-nokit"><a href="#更新-nokit" class="headerlink" title="更新 nokit"></a>更新 nokit</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[sudo] npm update nokitjs [-g]</div></pre></td></tr></table></figure>
<h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>使用 “<figure class="highlight plain"><figcaption><span>时必须```全局```安装 nokitjs (全局安装的同时也可以在 app 中本地安装 nokitjs)，Nokit 应用只需在磁盘建立应用目录，并新建相关文件和目录即可， Nokit 提供了方便的命令行工具。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;命令行工具还提供了进程管理相关功能，确保应用能够持续稳定的运行，并能在遇到故障时快速自动恢复。</div><div class="line"></div><div class="line">#### 查看版本</div><div class="line">```sh</div><div class="line">[sudo] nokit [?]</div></pre></td></tr></table></figure></p>
<h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[sudo] nokit create [name] [mvc|nsp|restful] [folder]</div></pre></td></tr></table></figure>
<p>以上命令会生成一个最简单的应用所需要的目录结构和配置。</p>
<ol>
<li>name 一般不建议省略（省略时为 nokit-app），name 将会作为应用的根目录名称</li>
<li>type 默认为 mvc 也可以指定为 nsp 或 restful ，指定类型后将会创建对应的应用模板</li>
<li>folder 为目标目录，省略时将默认为当前所在目录。</li>
</ol>
<h4 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[sudo] nokit start [port] [root] [-env:&lt;name&gt;] [-cluster[:num]] [-watch[:.ext,...]] [node-opts]</div></pre></td></tr></table></figure>
<ol>
<li>-env 指定运行配置名称，将会根据 “配置名称” 加载 app.xxx.json (xxx 为指定的配置名称) 作为应用配置文件。</li>
<li>-cluster 选项可以开启 “单机集群模式”，使应用有效的利用多核 CPU，也使应用更加健壮可靠，-cluster 选项可以指定进程数，如 -cluster:4 ，默认为 CPU 核数。</li>
<li>-watch 选项开启后，在应用文件发生改变时会自动完成进程重启，默认任何文件变更都将触发重启，也可以指定文件类型，如 -watch:.js,.html,.css</li>
<li>-public 一般用于为 html/js/css 等静态资源启动一个临时 WebServer，指定静态资源目录，静态资源目录为 root 的相对目录。</li>
<li>-cache 一般用于为 html/js/css 等静态资源启动一个临时 WebServer，指定缓存配置，例如 -cache:0 不向浏览器发送缓存 header 信息。</li>
<li>–debug 为 nodejs 选项，可以开启 debug 模式，开启后可以使用 nodejs 内置调试工具调式，也可以使用 node-inspector 等工具进行调试。</li>
</ol>
<h4 id="停止应用"><a href="#停止应用" class="headerlink" title="停止应用"></a>停止应用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[sudo] nokit stop [pid|all]</div></pre></td></tr></table></figure>
<p>可以指定 pid (进程ID，可以用过 nokit list 查看)，停止指定的的应用，也可以省略停止所有应用</p>
<h4 id="重启应用"><a href="#重启应用" class="headerlink" title="重启应用"></a>重启应用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[sudo] nokit restart [pid|all]</div></pre></td></tr></table></figure>
<p>可以指定 pid (进程ID，可以用过 nokit list 查看)，重启指定的的应用，也可以省略重启所有应用</p>
<h4 id="查看运行中的应用"><a href="#查看运行中的应用" class="headerlink" title="查看运行中的应用"></a>查看运行中的应用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[sudo] nokit list</div></pre></td></tr></table></figure>
<p>查看所有已启动的应用</p>
<h4 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[sudo] nokit autostart [on|off] [-uid:[domain\]user [-pwd:password]]</div></pre></td></tr></table></figure>
<p>autostart 命令目前支持 win32 和 linux 平台，此命令需要管理员权限，如 ubuntu 需要使用 <figure class="highlight plain"><figcaption><span>，</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">在 windows 平台会弹出 &quot;用户账户控制&quot; 提示框。</div><div class="line">-uid 和 -pwd 参数仅在 win32 平台有效，其它平台将被忽略，在不指定 -uid 、-pwd 参数时，需有用户登录到 windows </div><div class="line">才会自动启动 Nokit App，当指定 -uid、-pwd 时，只要启动 windows 就会自动启动 Nokit App。</div><div class="line">无论是登录 windows 的账户或是通过 -uid 提定的账户，需要是安装 nodejs 和 npm 时所用的账户。</div><div class="line"></div><div class="line">## 在代码中引用</div><div class="line">除了使用命令行工具，也可以在代码中引用 nokit 的方式来运行 nokit 应用，</div><div class="line">在代码中引用 nokit，将不能利用 nokit 的进程管理功能，这时可以直接运行，或者使用 pm2、forever 等工具进行管理。</div><div class="line">```javascript</div><div class="line">var nokit = require(&quot;nokitjs&quot;);</div><div class="line">var server = new nokit.Server(&#123;</div><div class="line">    root : &quot;应用根目录&quot;,</div><div class="line">    port : 8000</div><div class="line">&#125;);</div><div class="line">server.start();</div></pre></td></tr></table></figure></p>
<p>无论任种方式，启动成功后，即可浏览器访问 “<a href="http://localhost:8000" target="_blank" rel="external">http://localhost:8000</a>“ (端口请换成具体应用的正确的端口)，<br>示例站点 <a href="http://jser.cc" target="_blank" rel="external">http://jser.cc</a> (还未全部开发完毕)</p>
<h2 id="NSP"><a href="#NSP" class="headerlink" title="NSP"></a>NSP</h2><p>NSP 全称为 <figure class="highlight plain"><figcaption><span>Server Pages``` 是一种类似 ```asp / asp.net``` 的 Web 应用开发模式，</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">NSP 支持 include 引用其它页面，也支持 ```master 母板页``` 技术。</div><div class="line"></div><div class="line">一般目录结构</div><div class="line">```javascript</div><div class="line">根目录</div><div class="line">│ app.json</div><div class="line">│ app.js</div><div class="line">├─layout</div><div class="line">│     date.nsp</div><div class="line">│     master.nsp</div><div class="line">├─model</div><div class="line">└─public</div><div class="line">    │  index.nsp</div><div class="line">    │  index.nsp.js</div><div class="line">    └─style</div><div class="line">         common.css</div></pre></td></tr></table></figure></p>
<p>NSP 页面 (*.nsp) 基本介绍</p>
<p>输出内容<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">%=</span> "输出内容" %&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- this 指向页面处理器，无处理器页面指向默认处理器对象 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">%=</span> <span class="attr">this.context.request.formData</span>("<span class="attr">name</span>") %&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>循环<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">%</span> $<span class="attr">.each</span>(<span class="attr">this.list</span>,<span class="attr">function</span>(<span class="attr">i</span>,<span class="attr">item</span>)&#123; %&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">item.name</span> %&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">%</span> &#125;) %&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>分支<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span>(<span class="attr">this.type</span>==<span class="string">'a'</span>)&#123; %&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>a<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">%</span> &#125;<span class="attr">else</span>&#123; %&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>b<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></div></pre></td></tr></table></figure></p>
<p>包含<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">%</span> $<span class="attr">.include</span>("<span class="attr">..</span>/<span class="attr">layout</span>/<span class="attr">head.nsp</span>") %&gt;</span></div></pre></td></tr></table></figure></p>
<p>母板页(<figure class="highlight plain"><figcaption><span>Page```)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">```html</div><div class="line">&lt;html&gt;</div><div class="line">...</div><div class="line">&lt;div&gt; &lt;% $.placeHolder(&quot;content1&quot;) %&gt; &lt;/div&gt;</div><div class="line">...</div><div class="line">&lt;div&gt; &lt;% $.placeHolder(&quot;content2&quot;) %&gt; &lt;/div&gt;</div><div class="line">...</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>内容页(<figure class="highlight plain"><figcaption><span>Page```)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">```html</div><div class="line">&lt;% $.master(&quot;./master.nsp&quot;) %&gt;</div><div class="line"></div><div class="line">&lt;% $.placeBegin(&quot;content1&quot;) %&gt;</div><div class="line">&lt;span&gt;content1&lt;/span&gt;</div><div class="line">&lt;% $.placeEnd() %&gt;</div><div class="line"></div><div class="line">&lt;% $.placeBegin(&quot;content2&quot;) %&gt;</div><div class="line">&lt;span&gt;content2&lt;/span&gt;</div><div class="line">&lt;% $.placeEnd() %&gt;</div></pre></td></tr></table></figure></p>
<p>NSP 页面处理器 (*.nsp.js) 基本介绍<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义页面处理器类型</span></div><div class="line"><span class="keyword">var</span> IndexPresenter = <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//初始化方法，每次回发都将触发 init 方法</span></div><div class="line">IndexPresenter.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">/*</span></div><div class="line">    self.server //当前 server 实例</div><div class="line">    self.context //当前请上下文对象</div><div class="line">    self.request //同 context.request，请求对象</div><div class="line">    self.response //同 context.response 响应对象</div><div class="line">    self.context.request.queryData['name'] 可以获取 queryString 对应数据</div><div class="line">    self.context.request.formData['name'] 可以获取 post 数据</div><div class="line">    self.context.data("name") 可以获取客户端传过来的 queryString 或 formData</div><div class="line">    self.context.request.cookie 获取来自客户的 cookie</div><div class="line">    self.context.respone.cookie 向客户端发送 cookie</div><div class="line">    se轩.context.session 访问 session 数据</div><div class="line">    */</div><div class="line">    self.name = <span class="string">'Nokit NSP'</span>;</div><div class="line">    <span class="comment">//init（初始化）完成后，需要调用 ready 方法，通知初始化完成</span></div><div class="line">    self.ready();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//默认方法，首次打开页面，会触发 load 方法</span></div><div class="line">IndexPresenter.prototype.load = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">//由于 nokit 为异步处理，调用 self.render() 方法向浏览器呈现页面.</span></div><div class="line">    <span class="comment">//不要在 init 方法调用 self.render() </span></div><div class="line">    self.render();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//事件方法，可以绑定到页面中的 html 控件</span></div><div class="line">IndexPresenter.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> val = <span class="built_in">parseInt</span>(self.numBox.val());</div><div class="line">    self.numBox.val(++val);</div><div class="line">    self.numBox.css(<span class="string">"border"</span>,<span class="string">"solid 1px red"</span>);</div><div class="line">    self.render();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>页面绑定<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 绑定到处理器方法 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"nsp.call('add')"</span> <span class="attr">value</span>=<span class="string">'add'</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<blockquote>
<figure class="highlight plain"><figcaption><span>DOM 元素通过 "```nsp-id```" 声明为客户端和服务端的共享元素，便可以在客户端和服务端同时操作指定元素，</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; 并能在回发时保持状态，类似 Asp.NET 的 WebForms，但理念、原理又非常不同，NSP 共享元素非常轻量，更简洁易用。</div><div class="line"></div><div class="line">```html</div><div class="line">&lt;!-- 此元素可以在服务端和客户端同时访问 --&gt;</div><div class="line">&lt;input type=&quot;text&quot; value=&quot;hello&quot; nsp-id=&apos;test&apos; /&gt;</div></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Index.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">//服务端提供类 jQuery 的元素操作 API (兼容部分常用 jQUery API)</span></div><div class="line">    self.test.val(<span class="string">'你好'</span>); </div><div class="line">    self.render();</div><div class="line">&#125;;</div><div class="line"><span class="string">``</span><span class="string">`    </span></div><div class="line"></div><div class="line">## MVC</div><div class="line">Nokit MVC 是一种设计简约、符合 MVC 模式 Web 应用开发模式。</div><div class="line"></div><div class="line">一般目录结构</div><div class="line"></div><div class="line">`<span class="string">``</span>javascript</div><div class="line">根目录</div><div class="line">│ app.json</div><div class="line">│ app.js</div><div class="line">├─controllers</div><div class="line">│    home.js</div><div class="line">├─models</div><div class="line">├─public</div><div class="line">│  └─style</div><div class="line">│       common.css</div><div class="line">└─views</div><div class="line">     date.html</div><div class="line">     home.html</div><div class="line">     master.html</div></pre></td></tr></table></figure>
<blockquote>
<p>views 目录存放的是视图，视图和 NSP 的页面相似，支持 include 和 master，语法也完全相同，<br>不同的是在 mvc 的视图中 <figure class="highlight plain"><figcaption><span>指向的是模型，视图具有单一的责职 ，就是呈现模型中的数据。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">controllers 是控制器目录，单个文件为一个控制器，用来响应接受来自用户的请求，并传递给模型，</div><div class="line">然后，完成模型和视图的装配。</div><div class="line">models 为模型目录，nokit 对模型没有统一的要求和控制，应用的业务逻辑应在模型中完成。</div><div class="line"></div><div class="line">MVC 的控制器示例</div><div class="line">```javascript</div><div class="line">//定义控制器类型</div><div class="line">var HomeController = module.exports = function() &#123;&#125;;</div><div class="line"></div><div class="line">/*</div><div class="line">默认 action ，</div><div class="line">通常用户直接请求某一 url 会被路由到指定 controller 的默认 action</div><div class="line">*/</div><div class="line">HomeController.prototype.index = function() &#123;</div><div class="line">    var self = this;</div><div class="line">    </div><div class="line">    /*</div><div class="line">    self.context 可以访问当前请求上下文对象</div><div class="line">    self.context.routeData[&quot;name&quot;] 可以获取路由数据</div><div class="line">    self.context.request.queryData[&apos;name&apos;] 可以获取 queryString 对应数据</div><div class="line">    self.context.request.formData[&apos;name&apos;] 可以获取 post 数据</div><div class="line">    self.context.data(&quot;name&quot;) 可以获取客户端传过来的 queryString 或 formData</div><div class="line">    self.context.request.cookie 获取来自客户的 cookie</div><div class="line">    self.context.respone.cookie 向客户端发送 cookie</div><div class="line">    se轩.context.session 访问 session 数据</div><div class="line">    */</div><div class="line">    </div><div class="line">    //通过 self.render 方法呈现指定的视图，并进行模型绑定</div><div class="line">    self.render(&quot;home.html&quot;, &#123;</div><div class="line">        &quot;name&quot;: &quot;Nokit MVC&quot;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>MVC 的 app.json 配置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">    配置 handler ，将指定的请求交由 MVC Handler 处理，支持正则表达式，</div><div class="line">    如示例，将应用的所有请求都交由 MVC 处理，</div><div class="line">    在找不到匹配的路由配置时，会转由 Static Handler 处理</div><div class="line">    */</div><div class="line">    <span class="string">"handlers"</span>: &#123;</div><div class="line">        <span class="string">"^/"</span>: <span class="string">"$./handlers/mvc"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"mvc"</span>: &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">        配置 MVC 相关代码文件的存放目录，指定 controller 和 view 的目录位置，</div><div class="line">        model 不用配置。</div><div class="line">        */</div><div class="line">        <span class="string">"paths"</span>: &#123;</div><div class="line">            <span class="string">"controller"</span>: <span class="string">"./controllers"</span>,</div><div class="line">            <span class="string">"view"</span>: <span class="string">"./views"</span></div><div class="line">        &#125;,</div><div class="line">        <span class="comment">/*</span></div><div class="line">        每一个路由至少需要指定 pattern(URL匹配模式) 和 target(目标contrller)</div><div class="line">        还可以通过配置 action 项指定对应的 action (controller方法)。</div><div class="line">        pattern 格式示例 "/user/&#123;userId&#125;" 其中 userId 是占位符变量，</div><div class="line">        可以在 controller 中通过 context.routeData['userId'] 获取。</div><div class="line">        */</div><div class="line">        <span class="string">"routes"</span>: [&#123;</div><div class="line">            <span class="string">"pattern"</span>: <span class="string">"/home"</span>,</div><div class="line">            <span class="string">"target"</span>: <span class="string">"./home.js"</span></div><div class="line">        &#125;,&#123;</div><div class="line">            <span class="string">"pattern"</span>: <span class="string">"/"</span>,</div><div class="line">            <span class="string">"target"</span>: <span class="string">"./home.js"</span></div><div class="line">        &#125;]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p>Nokit 用来开发 RESTful Service 是非常方便和简单的，通过简洁的 URL 路由配置，抽象出和资源对应的请求处理程序文件即可，<br>可以在处理程序中，根据需求实现 get / post / put 等 HttpMethod 即可。</p>
<p>一般目录结构<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">根目录</div><div class="line">│ app.json</div><div class="line">│ app.js</div><div class="line">├─public</div><div class="line">│  │  index.nsp</div><div class="line">│  └─style</div><div class="line">│       common.css</div><div class="line">└─restful</div><div class="line">      user.js</div></pre></td></tr></table></figure></p>
<p>REST 的资源控制器示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义资源控制器类型，通常一个资源类型视为一个控制器</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloController</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * post 处理方法</div><div class="line"> **/</div><div class="line">HelloController.prototype.post = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">/*</span></div><div class="line">    self.context 可以访问当前请求上下文对象</div><div class="line">    self.context.routeData["name"] 可以获取路由数据</div><div class="line">    self.context.request.queryData['name'] 可以获取 queryString 对应数据</div><div class="line">    self.context.request.formData['name'] 可以获取 post 数据</div><div class="line">    self.context.data("name") 可以获取客户端传过来的 queryString 或 formData</div><div class="line">    self.context.request.body 可以访问请求的主体对象</div><div class="line">    */</div><div class="line">    self.out(&#123;</div><div class="line">        <span class="string">"status"</span>: <span class="string">"success"</span>,</div><div class="line">        <span class="string">"message"</span>: <span class="string">"Hello "</span> + self.context.routeData[<span class="string">"name"</span>] + <span class="string">"!"</span></div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * get 处理方法</div><div class="line"> **/</div><div class="line">HelloController.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    self.out(&#123;</div><div class="line">        <span class="string">"status"</span>: <span class="string">"success"</span>,</div><div class="line">        <span class="string">"message"</span>: <span class="string">"Hello "</span> + self.context.routeData[<span class="string">"name"</span>] + <span class="string">"!"</span></div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>REST 的 app.json 配置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">    配置 handler ，将指定的请求交由 REST Handler 处理，支持正则表达式，</div><div class="line">    如示例，/api/... 开头的请求，交由 REST Handler 处理</div><div class="line">    */</div><div class="line">    <span class="string">"handlers"</span>: &#123;</div><div class="line">        <span class="string">"^/api/"</span>: <span class="string">"$./handlers/restful"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"restful"</span>: &#123;</div><div class="line">        <span class="string">"path"</span>: <span class="string">"./restful"</span>, <span class="comment">//指定资源控制器的存放目录</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">        每一个路由至少需要指定 pattern(URL匹配模式) 和 target(目标contrller)</div><div class="line">        pattern 格式示例 "/user/&#123;userId&#125;" 其中 userId 是占位符变量，</div><div class="line">        REST 的路由配置没有 action 配置项。</div><div class="line">        */</div><div class="line">        <span class="string">"routes"</span>: [&#123;</div><div class="line">             <span class="string">"pattern"</span>: <span class="string">"/api/hello/&#123;name&#125;"</span>,</div><div class="line">             <span class="string">"target"</span>: <span class="string">"./hello"</span></div><div class="line">        &#125;]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>Filter 可以在请求的不同阶段截获请求，进行相关逻辑处理后，继续向下处理请求或结束请求，一个完整的 filter 包括 4 个事件，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义一个 Filter</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DemoFilter</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//在请求开始时</span></div><div class="line">DemoFilter.prototype.onRequestBegin = <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</div><div class="line">    next();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//在收到数据时</span></div><div class="line">DemoFilter.prototype.onReceived = <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</div><div class="line">    next();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//在向客户端响应内容时</span></div><div class="line">DemoFilter.prototype.onResponse = <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</div><div class="line">    next();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//在请求即将结束时</span></div><div class="line">DemoFilter.prototype.onRequestEnd = <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</div><div class="line">    next();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在应用中注册 Filter，在 <figure class="highlight plain"><figcaption><span>app.json``` 中配置:</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">```js</div><div class="line">&#123;</div><div class="line">    &quot;filters&quot;:&#123;</div><div class="line">        &quot;^/&quot;:&quot;./filters/demo-filter.js&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Nokit 是一个简单易用的基于 Nodejs 的 Web 开发框架，默认提供了 MVC / NSP / RESTful 等支持，并提供对应项目模板、管理工具。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>一个用于前端开发的实时更新工具 - iweb</title>
    <link href="http://blog.houfeng.net/2015/10/18/iweb/"/>
    <id>http://blog.houfeng.net/2015/10/18/iweb/</id>
    <published>2015-10-17T16:00:00.000Z</published>
    <updated>2016-08-27T04:40:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>iweb 一个用于前端开发的工具，<br>可以在文件发生变化时，实时自动在浏览器中刷新页面，或者精确的识别不同类型更新内容，<br>更细粒度的实时无刷新的更新 “样式、图片” 等资源,<br>无需任何浏览器插件，无需手动添加 “client-script”, 可以同时连接不限数量的多个设备。</p>
<p>GitHub: <a href="https://github.com/Houfeng/iweb" target="_blank" rel="external">https://github.com/Houfeng/iweb</a> (欢迎 star、fork)<br>iweb 基于 <a href="https://github.com/Houfeng/nokit" target="_blank" rel="external">Nokit</a> 开发，主页: <a href="http://houfeng.net/iweb/" target="_blank" rel="external">http://houfeng.net/iweb/</a></p>
<a id="more"></a>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[sudo] npm install iweb -g</div></pre></td></tr></table></figure>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[sudo] npm update iweb -g</div></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd &lt;工作目录&gt;</div><div class="line">iweb [port]</div></pre></td></tr></table></figure>
<p>启动后用PC或移动设备的浏览器直接访问 “<a href="http://localhost[:端口]&quot;，" target="_blank" rel="external">http://localhost[:端口]&quot;，</a><br>在文件发生任何变化时，iweb 会即时完成浏览器端刷新或更新。</p>
<h3 id="在手机中访问"><a href="#在手机中访问" class="headerlink" title="在手机中访问"></a>在手机中访问</h3><p>在手机上输入一个 url 是比较麻烦的， 可以通过访问 “<a href="http://locahost[:端口]/-dev" target="_blank" rel="external">http://locahost[:端口]/-dev</a>“ 可以打开 “工具” 页面，<br>在这个面页会为本机的每一个 ip 生成一个 “二维码”，可以用手机扫描，轻松访问。</p>
<h3 id="页面审查工具"><a href="#页面审查工具" class="headerlink" title="页面审查工具"></a>页面审查工具</h3><p>iweb 提供一个，基于 weinre（<a href="https://github.com/Houfeng/nokit" target="_blank" rel="external">Nokit</a> 重写的版本）的页面检查工具。<br>可以通过访问 “<a href="http://locahost[:端口]/-dev" target="_blank" rel="external">http://locahost[:端口]/-dev</a>“ 可以打开 “工具” 页面，<br>然后点击 “Inspector” 打开，类似 chrome devtool 的 “页面审查工具”</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;iweb 一个用于前端开发的工具，&lt;br&gt;可以在文件发生变化时，实时自动在浏览器中刷新页面，或者精确的识别不同类型更新内容，&lt;br&gt;更细粒度的实时无刷新的更新 “样式、图片” 等资源,&lt;br&gt;无需任何浏览器插件，无需手动添加 “client-script”, 可以同时连接不限数量的多个设备。&lt;/p&gt;
&lt;p&gt;GitHub: &lt;a href=&quot;https://github.com/Houfeng/iweb&quot;&gt;https://github.com/Houfeng/iweb&lt;/a&gt; (欢迎 star、fork)&lt;br&gt;iweb 基于 &lt;a href=&quot;https://github.com/Houfeng/nokit&quot;&gt;Nokit&lt;/a&gt; 开发，主页: &lt;a href=&quot;http://houfeng.net/iweb/&quot;&gt;http://houfeng.net/iweb/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>一个 markdown 编辑器 - Mditor</title>
    <link href="http://blog.houfeng.net/2015/10/09/mditor/"/>
    <id>http://blog.houfeng.net/2015/10/09/mditor/</id>
    <published>2015-10-08T16:00:00.000Z</published>
    <updated>2016-08-27T04:39:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="只求极致"><a href="#只求极致" class="headerlink" title="只求极致"></a>只求极致</h2><p>[ <strong>M</strong> ] arkdown + E [ <strong>ditor</strong> ] = <strong>Mditor</strong>    </p>
<p>Mditor 是一个简洁、易于集成、方便扩展、期望舒服的编写 markdown 的编辑器，仅此而已…  </p>
<p>GitHub: <a href="https://github.com/houfeng/mditor" target="_blank" rel="external">https://github.com/houfeng/mditor</a> (欢迎 star、fork)<br>主页: <a href="http://houfeng.net/mditor/" target="_blank" rel="external">http://houfeng.net/mditor/</a>   </p>
<a id="more"></a>
<p><img src="/img/bVqgsF" alt="Mditor"></p>
<h2 id="浏览器端"><a href="#浏览器端" class="headerlink" title="浏览器端"></a>浏览器端</h2><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步:"></a>第一步:</h5><p>引入 Mditor 样式文件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"../build/css/mditor.min.css"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>引用 Mditor 脚本文件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../build/js/mditor.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步:"></a>第二步:</h5><p>添加 textarea 元素<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"editor"</span> <span class="attr">id</span>=<span class="string">"editor"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>创建 Mditor 实例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mditor = <span class="keyword">new</span> Mditor(<span class="string">"#editor"</span>,&#123;</div><div class="line">	height:<span class="number">300</span>,</div><div class="line">	fixedHeight:<span class="literal">true</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>通过 npm 安装<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install mditor -save</div></pre></td></tr></table></figure></p>
<p>在服务端解析<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mditor = <span class="built_in">require</span>(<span class="string">"mditor"</span>);</div><div class="line"><span class="keyword">var</span> parser = mditor.Parser();</div><div class="line"><span class="keyword">var</span> html = parser.parse(<span class="string">"** Hello mditor! **"</span>);</div></pre></td></tr></table></figure></p>
<h2 id="近时规划"><a href="#近时规划" class="headerlink" title="近时规划"></a>近时规划</h2><ol>
<li>公开扩展方法及相关 API</li>
<li>更新 README.md 增加完整 API 说明</li>
<li>国际化支持</li>
<li>兼容性测试</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;只求极致&quot;&gt;&lt;a href=&quot;#只求极致&quot; class=&quot;headerlink&quot; title=&quot;只求极致&quot;&gt;&lt;/a&gt;只求极致&lt;/h2&gt;&lt;p&gt;[ &lt;strong&gt;M&lt;/strong&gt; ] arkdown + E [ &lt;strong&gt;ditor&lt;/strong&gt; ] = &lt;strong&gt;Mditor&lt;/strong&gt;    &lt;/p&gt;
&lt;p&gt;Mditor 是一个简洁、易于集成、方便扩展、期望舒服的编写 markdown 的编辑器，仅此而已…  &lt;/p&gt;
&lt;p&gt;GitHub: &lt;a href=&quot;https://github.com/houfeng/mditor&quot;&gt;https://github.com/houfeng/mditor&lt;/a&gt; (欢迎 star、fork)&lt;br&gt;主页: &lt;a href=&quot;http://houfeng.net/mditor/&quot;&gt;http://houfeng.net/mditor/&lt;/a&gt;   &lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 之 “包装器对象”</title>
    <link href="http://blog.houfeng.net/2014/12/15/javascript-wraper/"/>
    <id>http://blog.houfeng.net/2014/12/15/javascript-wraper/</id>
    <published>2014-12-14T16:00:00.000Z</published>
    <updated>2016-08-27T04:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在JavaScript中，“一切皆对象”，数组和函数本质上都是对象，就连三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。</p>
<p>所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</div><div class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</div><div class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>上面代码根据原始类型的值，生成了三个对象，与原始值的类型不同。这用typeof运算符就可以看出来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typeof</span> v1 <span class="comment">// "object"</span></div><div class="line"><span class="keyword">typeof</span> v2 <span class="comment">// "object"</span></div><div class="line"><span class="keyword">typeof</span> v3 <span class="comment">// "object"</span></div><div class="line"></div><div class="line">v1 === <span class="number">123</span> <span class="comment">// false</span></div><div class="line">v2 === <span class="string">"abc"</span> <span class="comment">// false</span></div><div class="line">v3 === <span class="literal">true</span> <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>JavaScript设计包装对象的最大目的，首先是使得JavaScript的“对象”涵盖所有的值。其次，使得原始类型的值可以方便地调用特定方法。</p>
<h3 id="包装对象的构造函数"><a href="#包装对象的构造函数" class="headerlink" title="包装对象的构造函数"></a>包装对象的构造函数</h3><p>Number、String和Boolean这三个原生对象，既可以当作构造函数使用（即加上new关键字，生成包装对象实例），也可以当作工具方法使用（即不加new关键字，直接调用），这相当于生成实例后再调用valueOf方法，常常用于将任意类型的值转为某种原始类型的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Number</span>(<span class="number">123</span>) <span class="comment">// 123</span></div><div class="line"></div><div class="line"><span class="built_in">String</span>(<span class="string">"abc"</span>) <span class="comment">// "abc"</span></div><div class="line"></div><div class="line"><span class="built_in">Boolean</span>(<span class="literal">true</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>工具方法的详细介绍参见第二章的《数据类型转换》一节。</p>
<h3 id="包装对象实例的方法"><a href="#包装对象实例的方法" class="headerlink" title="包装对象实例的方法"></a>包装对象实例的方法</h3><p>包装对象实例可以使用Object对象提供的原生方法，主要是 valueOf 方法和 toString 方法。</p>
<p><strong>（1）valueOf方法</strong></p>
<p>valueOf方法返回包装对象实例对应的原始类型的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>).valueOf()</div><div class="line"><span class="comment">// 123</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>).valueOf()</div><div class="line"><span class="comment">// "abc"</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"true"</span>).valueOf()</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><strong>（2）toString方法</strong></p>
<p>toString方法返回该实例对应的原始类型值的字符串形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>).toString()</div><div class="line"><span class="comment">// "123"</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>).toString()</div><div class="line"><span class="comment">// "abc"</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"true"</span>).toString()</div><div class="line"><span class="comment">// "true"</span></div></pre></td></tr></table></figure>
<h3 id="原始类型的自动转换"><a href="#原始类型的自动转换" class="headerlink" title="原始类型的自动转换"></a>原始类型的自动转换</h3><p>原始类型可以自动调用定义在包装对象上的方法和属性。比如String对象的实例有一个length属性，返回字符串的长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</div><div class="line">v.length <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>所有原始类型的字符串，都可以直接使用这个length属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="string">"abc"</span>.length <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>上面代码对字符串abc调用length属性，实际上是将“字符串”自动转为String对象的实例，再在其上调用length属性。这就叫原始类型的自动转换。</p>
<p>abc是一个字符串，属于原始类型，本身不能调用任何方法和属性。但当对abc调用length属性时，JavaScript引擎自动将abc转化为一个包装对象实例，然后再对这个实例调用length属性，在得到返回值后，再自动销毁这个临时生成的包装对象实例。</p>
<p>这种原始类型值可以直接调用的方法还有很多（详见后文对各包装对象的介绍），除了前面介绍过的valueOf和stringOf方法，还包括三个包装对象各自定义在实例上的方法。。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="string">'abc'</span>.charAt === <span class="built_in">String</span>.prototype.charAt</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码表示，字符串abc的charAt方法，实际上就是定义在String对象实例上的方法（关于prototype对象的介绍参见《面向对象编程》一章）。</p>
<p>如果包装对象与原始类型值进行混合运算，包装对象会转化为原始类型（实际是调用自身的valueOf方法）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) + <span class="number">123</span></div><div class="line"><span class="comment">// 246</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>) + <span class="string">"abc"</span></div><div class="line"><span class="comment">// "abcabc"</span></div></pre></td></tr></table></figure>
<h3 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h3><p>三种包装对象还可以在原型上添加自定义方法和属性，供原始类型的值直接调用。</p>
<p>比如，我们可以新增一个double方法，使得字符串和数字翻倍。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">String</span>.prototype.double = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.valueOf() + <span class="keyword">this</span>.valueOf();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="string">"abc"</span>.double()</div><div class="line"><span class="comment">// abcabc</span></div><div class="line"></div><div class="line"><span class="built_in">Number</span>.prototype.double = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.valueOf() + <span class="keyword">this</span>.valueOf();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">(<span class="number">123</span>).double()</div><div class="line"><span class="comment">// 246</span></div></pre></td></tr></table></figure>
<p>上面代码在123外面必须要加上圆括号，否则后面的点运算符（.）会被解释成小数点。</p>
<p>但是，这种自定义方法和属性的机制，只能定义在包装对象的原型上，如果直接对原始类型的变量添加属性，则无效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> s = <span class="string">"abc"</span>;</div><div class="line"></div><div class="line">s.p = <span class="number">123</span>;</div><div class="line">s.p <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>上面代码直接对支付串abc添加属性，结果无效。</p>
<h2 id="Boolean对象"><a href="#Boolean对象" class="headerlink" title="Boolean对象"></a>Boolean对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Boolean对象是JavaScript的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> b <span class="comment">// "object"</span></div><div class="line">b.valueOf() <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码的变量b是一个Boolean对象的实例，它的类型是对象，值为布尔值true。这种写法太繁琐，几乎无人使用，直接对变量赋值更简单清晰。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</div></pre></td></tr></table></figure>
<h3 id="Boolean实例对象的布尔值"><a href="#Boolean实例对象的布尔值" class="headerlink" title="Boolean实例对象的布尔值"></a>Boolean实例对象的布尔值</h3><p>特别要注意的是，所有对象的布尔运算结果都是true。因此，false对应的包装对象实例，布尔运算结果也是true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>); </div><div class="line">&#125; <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>).valueOf()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>); </div><div class="line">&#125; <span class="comment">// 无输出</span></div></pre></td></tr></table></figure>
<p>上面代码的第一个例子之所以得到true，是因为false对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值true（所有对象对应的布尔值都是true）。而实例的valueOf方法，则返回实例对应的原始类型值，本例为false。</p>
<h3 id="Boolean函数的类型转换作用"><a href="#Boolean函数的类型转换作用" class="headerlink" title="Boolean函数的类型转换作用"></a>Boolean函数的类型转换作用</h3><p>Boolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="number">1</span>) <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="string">'false'</span>) <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>([]) <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="regexp">/foo/</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码中几种得到true的情况，都值得认真记住。</p>
<p>使用not运算符（!）也可以达到同样效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">!!<span class="literal">undefined</span> <span class="comment">// false</span></div><div class="line">!!<span class="literal">null</span> <span class="comment">// false</span></div><div class="line">!!<span class="number">0</span> <span class="comment">// false</span></div><div class="line">!!<span class="string">''</span> <span class="comment">// false</span></div><div class="line">!!<span class="literal">NaN</span> <span class="comment">// false</span></div><div class="line">!!<span class="number">1</span> <span class="comment">// true</span></div><div class="line">!!<span class="string">'false'</span> <span class="comment">// true</span></div><div class="line">!![] <span class="comment">// true</span></div><div class="line">!!&#123;&#125; <span class="comment">// true</span></div><div class="line">!!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// true</span></div><div class="line">!!<span class="regexp">/foo/</span> <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>综上所述，如果要获得一个变量对应的布尔值，有多种写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="string">"hello world"</span>;</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(a).valueOf() <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>(a) <span class="comment">// true</span></div><div class="line">!!a <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>最后，对于一些特殊值，Boolean对象前面加不加new，会得到完全相反的结果，必须小心。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>(<span class="literal">false</span>)) </div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'true'</span>); <span class="comment">// 无输出</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'true'</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>(<span class="literal">null</span>)) </div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'true'</span>); <span class="comment">// 无输出</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">null</span>))</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'true'</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;包装对象&quot;&gt;&lt;a href=&quot;#包装对象&quot; class=&quot;headerlink&quot; title=&quot;包装对象&quot;&gt;&lt;/a&gt;包装对象&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;在JavaScript中，“一切皆对象”，数组和函数本质上都是对象，就连三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。&lt;/p&gt;
&lt;p&gt;所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.houfeng.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 之 “Array对象”</title>
    <link href="http://blog.houfeng.net/2014/11/15/javascript-array/"/>
    <id>http://blog.houfeng.net/2014/11/15/javascript-array/</id>
    <published>2014-11-14T16:00:00.000Z</published>
    <updated>2016-08-27T04:28:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Array是JavaScript的内置对象，同时也是一个构造函数，可以用它生成新的数组。</p>
<p>作为构造函数时，Array可以接受参数，但是不同的参数，会使得Array产生不同的行为。</p>
<a id="more"></a>
<ul>
<li><p>无参数时，返回一个空数组。</p>
</li>
<li><p>单个参数时，如果该参数是正整数，则这个正整数表示新数组的长度；如果该参数是非正整数（比如字符串、布尔值、对象等），则该值是新数组的成员。</p>
</li>
<li><p>多个参数时，这些参数都是新数组的成员。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> a3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'abc'</span>);</div><div class="line"><span class="keyword">var</span> a4 = <span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>]);</div><div class="line"><span class="keyword">var</span> a5 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line"></div><div class="line">a1 <span class="comment">// []</span></div><div class="line">a2 <span class="comment">// [undefined × 1]</span></div><div class="line">a3 <span class="comment">// ['abc']</span></div><div class="line">a4 <span class="comment">// [Array[1]]</span></div><div class="line">a5 <span class="comment">// [1, 2]</span></div></pre></td></tr></table></figure>
<p>从上面代码可以看到，Array的构造函数行为很不一致。因此，不建议使用它生成新数组，直接使用数组的字面量是更好的方法。</p>
<h2 id="Array对象的静态方法"><a href="#Array对象的静态方法" class="headerlink" title="Array对象的静态方法"></a>Array对象的静态方法</h2><h3 id="isArray方法"><a href="#isArray方法" class="headerlink" title="isArray方法"></a>isArray方法</h3><p>Array.isArray方法用来判断一个值是否为数组。它可以弥补typeof运算符的不足。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> a <span class="comment">// "object"</span></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.isArray(a) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码表示，typeof运算符只能显示数组的类型是Object，而Array.isArray方法可以对数组返回true。</p>
<h2 id="Array实例的方法"><a href="#Array实例的方法" class="headerlink" title="Array实例的方法"></a>Array实例的方法</h2><p>以下这些Array实例对象的方法，都是数组实例才能使用。如果不想创建实例，只是想单纯调用这些方法，可以写成 [].method.call(调用对象，参数) 的形式，或者 Array.prototype.method.call(调用对象，参数)的形式。</p>
<h3 id="valueOf方法，toString方法"><a href="#valueOf方法，toString方法" class="headerlink" title="valueOf方法，toString方法"></a>valueOf方法，toString方法</h3><p>valueOf方法返回数组本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"></div><div class="line">a.valueOf()</div><div class="line"><span class="comment">// [1,2,3]</span></div></pre></td></tr></table></figure>
<p>toString 方法返回数组的字符串形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"></div><div class="line">a.toString()</div><div class="line"><span class="comment">// "1,2,3"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]];</div><div class="line"></div><div class="line">a.toString()</div><div class="line"><span class="comment">// "1,2,3,4,5,6"</span></div></pre></td></tr></table></figure>
<h3 id="push方法，pop方法"><a href="#push方法，pop方法" class="headerlink" title="push方法，pop方法"></a>push方法，pop方法</h3><p>push方法用于在数组的末端添加一个或多个元素，并返回添加后的数组的长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"></div><div class="line">a.push(<span class="number">1</span>) <span class="comment">// 1</span></div><div class="line">a.push(<span class="string">"a"</span>) <span class="comment">// 2</span></div><div class="line">a.push(<span class="literal">true</span>, &#123;&#125;) <span class="comment">// 4</span></div><div class="line">a <span class="comment">// [1, "a", true, &#123;&#125;]</span></div></pre></td></tr></table></figure>
<p>上面代码使用push方法，先后往数组中添加了四个成员。</p>
<p>如果需要合并两个数组，可以这样写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.push.apply(a, b)</div><div class="line"><span class="comment">// 或者</span></div><div class="line">a.push.apply(a,b)</div><div class="line"></div><div class="line"><span class="comment">// 上面两种写法等同于</span></div><div class="line">a.push(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</div><div class="line"></div><div class="line">a</div><div class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></div></pre></td></tr></table></figure>
<p>push方法还可以用于向对象添加元素，添加后的对象变成“类似数组的”对象，即新加入元素的键对应数组的索引，并且对象有一个length属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123; a: <span class="number">1</span> &#125;;</div><div class="line"></div><div class="line">[].push.call(a, <span class="number">2</span>);</div><div class="line">a</div><div class="line"><span class="comment">// &#123;a:1, 0:2, length: 1&#125;</span></div><div class="line"></div><div class="line">[].push.call(a, [<span class="number">3</span>]);</div><div class="line">a</div><div class="line"><span class="comment">// &#123;a:1, 0:2, 1:[3], length: 2&#125;</span></div></pre></td></tr></table></figure>
<p>pop方法用于删除数组的最后一个元素，并返回该元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"></div><div class="line">a.pop() <span class="comment">// 'c'</span></div><div class="line">a <span class="comment">// ['a', 'b']</span></div></pre></td></tr></table></figure>
<p>对空数组使用pop方法，不会报错，而是返回undefined。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[].pop() <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<h3 id="join方法，concat方法"><a href="#join方法，concat方法" class="headerlink" title="join方法，concat方法"></a>join方法，concat方法</h3><p>join方法以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"></div><div class="line">a.join() <span class="comment">// "1,2,3,4"</span></div><div class="line">a.join(<span class="string">''</span>) <span class="comment">// '1234'</span></div><div class="line">a.join(<span class="string">"|"</span>) <span class="comment">// "1|2|3|4"</span></div></pre></td></tr></table></figure>
<p>通过函数的call方法，join方法（即Array.prototype.join）也可以用于字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.join.call(<span class="string">'hello'</span>, <span class="string">'-'</span>)</div><div class="line"><span class="comment">// "h-e-l-l-o"</span></div></pre></td></tr></table></figure>
<p>concat方法将新数组的成员，添加到原数组的尾部，然后返回一个新数组，常用于连接多个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="string">"hello"</span>].concat([<span class="string">"world"</span>])</div><div class="line"><span class="comment">// ["hello", "world"]</span></div><div class="line"></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].concat(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</div><div class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></div></pre></td></tr></table></figure>
<p>上面代码表明，concat方法的参数可以是一个或多个数组，以及原始类型的值。</p>
<p>如果不提供参数，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是如果数组成员包括复合类型的值（比如对象），则新数组拷贝的是该值的引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;a:<span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">var</span> oldArray = [o];</div><div class="line"></div><div class="line"><span class="keyword">var</span> newArray = oldArray.concat();</div><div class="line"></div><div class="line">o.a = <span class="number">2</span>;</div><div class="line">newArray[<span class="number">0</span>].a <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>上面代码中，原数组包含一个对象，concat方法生成的新数组包含这个对象的引用。所以，改变原对象以后，新数组跟着改变。事实上，只要原数组的成员中包含对象，concat方法不管有没有参数，总是返回该对象的引用。</p>
<p>concat方法也可以用于将对象合并为数组，但是必须借助call方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[].concat.call(&#123; a: <span class="number">1</span> &#125;, [<span class="number">2</span>])</div><div class="line"><span class="comment">// [&#123;a:1&#125;, 2]</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line">[<span class="number">2</span>].concat(&#123;a:<span class="number">1</span>&#125;)</div></pre></td></tr></table></figure>
<h3 id="shift方法，unshift方法"><a href="#shift方法，unshift方法" class="headerlink" title="shift方法，unshift方法"></a>shift方法，unshift方法</h3><p>shift方法用于删除数组的第一个元素，并返回该元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"></div><div class="line">a.shift() <span class="comment">// 'a'</span></div><div class="line">a <span class="comment">// ['b', 'c']</span></div></pre></td></tr></table></figure>
<p>shift方法可以遍历并清空一个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> item;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (item = list.shift()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(item);</div><div class="line">&#125;</div><div class="line"></div><div class="line">list <span class="comment">// []</span></div></pre></td></tr></table></figure>
<p>unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"></div><div class="line">a.unshift(<span class="string">'x'</span>); <span class="comment">// 4</span></div><div class="line">a <span class="comment">// ['x', 'a', 'b', 'c']</span></div></pre></td></tr></table></figure>
<h3 id="reverse方法"><a href="#reverse方法" class="headerlink" title="reverse方法"></a>reverse方法</h3><p>reverse方法用于颠倒数组中元素的顺序，使用这个方法以后，返回改变后的原数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"></div><div class="line">a.reverse() <span class="comment">// ["c", "b", "a"] </span></div><div class="line">a <span class="comment">// ["c", "b", "a"]</span></div></pre></td></tr></table></figure>
<h3 id="slice方法"><a href="#slice方法" class="headerlink" title="slice方法"></a>slice方法</h3><p>slice方法返回指定位置的数组成员组成的新数组，原数组不变。它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>];</div><div class="line"></div><div class="line">a.slice(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// ["b"]</span></div><div class="line">a.slice(<span class="number">1</span>) <span class="comment">// ["b", "c"]</span></div><div class="line">a.slice(<span class="number">0</span>) <span class="comment">// ["a","b","c"]</span></div><div class="line">a.slice(<span class="number">-2</span>) <span class="comment">// ["b", "c"]</span></div><div class="line">a.slice(<span class="number">4</span>) <span class="comment">// []</span></div><div class="line">a.slice(<span class="number">2</span>, <span class="number">6</span>) <span class="comment">// ["c"]</span></div><div class="line">a.slice(<span class="number">2</span>, <span class="number">1</span>) <span class="comment">// []</span></div></pre></td></tr></table></figure>
<p>上面代码表示，如果slice方法的参数是负数，则从尾部开始选择的成员个数；如果参数值大于数组成员的个数，或者第二个参数小于第一个参数，则返回空数组。</p>
<p>slice方法的一个重要应用，是将类似数组的对象转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.slice.call(&#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, length: <span class="number">2</span> &#125;)</div><div class="line"><span class="comment">// ['a', 'b']</span></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">"div"</span>));</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div></pre></td></tr></table></figure>
<p>上面代码的参数都不是数组，但是通过call方法，在它们上面调用slice方法，就可以把它们转为真正的数组。</p>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>splice方法用于删除元素，并可以在被删除的位置添加入新的数组元素。它的返回值是被删除的元素。需要特别注意的是，该方法会改变原数组。</p>
<p>splice的第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>];</div><div class="line"></div><div class="line">a.splice(<span class="number">4</span>,<span class="number">2</span>)</div><div class="line"><span class="comment">// ["e", "f"]</span></div><div class="line"></div><div class="line">a</div><div class="line"><span class="comment">// ["a", "b", "c", "d"]</span></div></pre></td></tr></table></figure>
<p>上面代码从原数组位置4开始，删除了两个数组成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>];</div><div class="line"></div><div class="line">a.splice(<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"><span class="comment">// ["e", "f"]</span></div><div class="line"></div><div class="line">a</div><div class="line"><span class="comment">// ["a", "b", "c", "d", 1, 2]</span></div></pre></td></tr></table></figure>
<p>上面代码除了删除成员，还插入了两个新成员。</p>
<p>如果只是单纯地插入元素，splice方法的第二个参数可以设为0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>];</div><div class="line"></div><div class="line">a.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>)</div><div class="line"><span class="comment">// []</span></div><div class="line"></div><div class="line">a</div><div class="line"><span class="comment">// [1, 2, 1, 1]</span></div></pre></td></tr></table></figure>
<p>如果只提供第一个参数，则实际上等同于将原数组在指定位置拆分成两个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"></div><div class="line">a.splice(<span class="number">2</span>)</div><div class="line"><span class="comment">// [3, 4]</span></div><div class="line"></div><div class="line">a</div><div class="line"><span class="comment">// [1, 2]</span></div></pre></td></tr></table></figure>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>sort方法对数组元素进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="string">"d"</span>,<span class="string">"c"</span>,<span class="string">"b"</span>,<span class="string">"a"</span>].sort()</div><div class="line"><span class="comment">// ["a", "b", "c", "d"]</span></div><div class="line"></div><div class="line">[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>].sort()</div><div class="line"><span class="comment">// [1, 2, 3, 4]</span></div><div class="line"></div><div class="line">[<span class="number">11</span>,<span class="number">101</span>].sort()</div><div class="line"><span class="comment">// [101, 11]</span></div><div class="line"></div><div class="line">[<span class="number">10111</span>,<span class="number">1101</span>,<span class="number">111</span>].sort()</div><div class="line"><span class="comment">// [10111, 1101, 111]</span></div></pre></td></tr></table></figure>
<p>上面代码的最后两个例子，需要特殊注意。sort方法不是按照大小排序，而是按照对应字符串的字典顺序排序，所以101排在11的前面。</p>
<p>如果想让sort方法按照大小排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">10111</span>,<span class="number">1101</span>,<span class="number">111</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a-b;</div><div class="line">&#125;)</div><div class="line"><span class="comment">// [111, 1101, 10111]</span></div><div class="line"></div><div class="line">[</div><div class="line">  &#123; name: <span class="string">"张三"</span>, age: <span class="number">30</span> &#125;,</div><div class="line">  &#123; name: <span class="string">"李四"</span>, age: <span class="number">24</span> &#125;,</div><div class="line">  &#123; name: <span class="string">"王五"</span>, age: <span class="number">28</span>  &#125;</div><div class="line">].sort(<span class="function"><span class="keyword">function</span>(<span class="params">o1, o2</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> o1.age - o2.age;</div><div class="line">&#125;)</div><div class="line"><span class="comment">// [</span></div><div class="line"><span class="comment">//   &#123; name: "李四", age: 24 &#125;,</span></div><div class="line"><span class="comment">//   &#123; name: "王五", age: 28  &#125;,</span></div><div class="line"><span class="comment">//   &#123; name: "张三", age: 30 &#125;</span></div><div class="line"><span class="comment">// ]</span></div></pre></td></tr></table></figure>
<h2 id="ECMAScript-5-新加入的数组方法"><a href="#ECMAScript-5-新加入的数组方法" class="headerlink" title="ECMAScript 5 新加入的数组方法"></a>ECMAScript 5 新加入的数组方法</h2><p>ECMAScript 5新增了9个数组实例的方法，分别是map、forEach、filter、every、some、reduce、reduceRight、indexOf和lastIndexOf。其中，前7个与函数式（functional）操作有关。</p>
<p>这些方法可以在数组上使用，也可以在字符串和类似数组的对象上使用，这是它们不同于传统数组方法的一个地方。</p>
<p>在用法上，这些方法的参数是一个函数，这个作为参数的函数本身又接受三个参数：数组的当前元素elem、该元素的位置index和整个数组arr（详见下面的实例）。另外，上下文对象（context）可以作为第二个参数，传入forEach(), every(), some(), filter(), map()方法，用来绑定函数运行时的上下文。</p>
<p>对于不支持这些方法的老式浏览器（主要是IE 8及以下版本），可以使用函数库<a href="https://github.com/kriskowal/es5-shim" target="_blank" rel="external">es5-shim</a>，或者<a href="http://underscorejs.org/#filter" target="_blank" rel="external">Underscore</a>和<a href="http://lodash.com/docs#filter" target="_blank" rel="external">Lo-Dash</a>。</p>
<h3 id="map方法，forEach方法"><a href="#map方法，forEach方法" class="headerlink" title="map方法，forEach方法"></a>map方法，forEach方法</h3><p>map方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line">numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="keyword">return</span> n+<span class="number">1</span> &#125;);</div><div class="line"><span class="comment">// [2, 3, 4]</span></div><div class="line"></div><div class="line">numbers</div><div class="line"><span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
<p>上面代码中，原数组的成员都加上1，组成一个新数组返回，原数组没有变化。</p>
<p>只要数组的成员可以被索引到，map方法就不会跳过它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="keyword">return</span> n+<span class="number">1</span> &#125;;</div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>].map(f) <span class="comment">// [2, NaN, 3]</span></div><div class="line">[<span class="number">1</span>, <span class="literal">null</span>, <span class="number">2</span>].map(f) <span class="comment">// [2, 1, 3]</span></div><div class="line">[<span class="number">1</span>, , <span class="number">2</span>].map(f) <span class="comment">// [2, undefined, 3]</span></div></pre></td></tr></table></figure>
<p>上面代码中，数组的成员分别是undefined、null和空位，map方法都不会跳过它们。</p>
<p>map方法的回调函数依次接受三个参数，分别是当前的数组成员、当前成员的位置和数组本身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">elem, index, arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> elem * elem;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// [1, 4, 9]</span></div></pre></td></tr></table></figure>
<p>有时，我们需要对字符串的每个字符进行遍历。这时可以通过函数的call方法，将map方法用于字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> upper = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x.toUpperCase() &#125;;</div><div class="line"></div><div class="line">[].map.call(<span class="string">'abc'</span>, upper)</div><div class="line"><span class="comment">// [ 'A', 'B', 'C' ]</span></div><div class="line"></div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="string">'abc'</span>.split(<span class="string">''</span>).map(upper)</div><div class="line"><span class="comment">// [ 'A', 'B', 'C' ]</span></div></pre></td></tr></table></figure>
<p>其他类似数组的对象（比如querySelectorAll方法返回DOM节点集合），也可以用上面的方法遍历。</p>
<p>map方法还可以接受第二个参数，表示回调函数执行时this所指向的对象。</p>
<p>数组实例的forEach方法与map方法很相似，也是遍历数组的所有成员，执行某种操作，但是forEach方法没有返回值。如果需要有返回值，一般使用map方法，如果只是单纯操作数据，一般使用forEach方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">element, index, array</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'['</span> + index + <span class="string">'] = '</span> + element);</div><div class="line">&#125;</div><div class="line"></div><div class="line">[<span class="number">2</span>, <span class="number">5</span>, , <span class="number">9</span>].forEach(log);</div><div class="line"><span class="comment">// [0] = 2</span></div><div class="line"><span class="comment">// [1] = 5</span></div><div class="line"><span class="comment">// [3] = 9</span></div></pre></td></tr></table></figure>
<p>从上面代码可以看到，forEach方法和map方法的参数格式是一样的，第一个参数都是一个函数。该函数接受三个参数，分别是当前元素、当前元素的位置（从0开始）、整个数组。</p>
<p>forEach方法会跳过数组的空位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="built_in">console</span>.log(n + <span class="number">1</span>) &#125;;</div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>].forEach(log)</div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// NaN</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="literal">null</span>, <span class="number">2</span>].forEach(log)</div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"></div><div class="line">[<span class="number">1</span>, , <span class="number">2</span>].map(f)</div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>上面代码中，forEach方法不会跳过undefined和null，但会跳过空位。</p>
<p>forEach方法也可以接受第二个参数，用来绑定回调函数的this关键字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> out = [];</div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">elem, index, arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.push(elem * elem);</div><div class="line">&#125;, out);</div><div class="line"></div><div class="line">out <span class="comment">// [1, 4, 9]</span></div></pre></td></tr></table></figure>
<p>上面代码表示，如果提供一个数组作为第二个参数，则函数内部的this关键字就指向这个数组。</p>
<h3 id="filter方法"><a href="#filter方法" class="headerlink" title="filter方法"></a>filter方法</h3><p>filter方法依次对所有数组成员调用一个测试函数，返回结果为true的成员组成一个新数组返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].filter(<span class="function"><span class="keyword">function</span> (<span class="params">elem</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> (elem &gt; <span class="number">3</span>);</div><div class="line">&#125;)</div><div class="line"><span class="comment">// [4,5]</span></div></pre></td></tr></table></figure>
<p>上面代码将大于3的原数组成员，作为一个新数组返回。</p>
<p>filter方法的测试函数可以接受三个参数，第一个参数是当前数组成员的值，这是必需的，后两个参数是可选的，分别是当前数组成员的位置和整个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem, index, arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> index % <span class="number">2</span> === <span class="number">0</span>;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// [1, 3, 5]</span></div></pre></td></tr></table></figure>
<p>上面代码返回原数组偶数位置的成员组成的新数组。</p>
<p>filter方法还可以接受第二个参数，指定测试函数所在的上下文对象（即this对象）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> Obj = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.MAX = <span class="number">3</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myFilter = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (item &gt; <span class="keyword">this</span>.MAX) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>];</div><div class="line">arr.filter(myFilter, <span class="keyword">new</span> Obj())</div><div class="line"><span class="comment">// [8, 4, 9]</span></div></pre></td></tr></table></figure>
<p>上面代码中，测试函数myFilter内部有this对象，它可以被filter方法的第二个参数绑定。</p>
<h3 id="some方法，every方法"><a href="#some方法，every方法" class="headerlink" title="some方法，every方法"></a>some方法，every方法</h3><p>这两个方法类似“断言”（assert），用来判断数组成员是否符合某种条件。</p>
<p>some方法对所有元素调用一个测试函数，只要有一个元素通过该测试，就返回true，否则返回false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].some(<span class="function"><span class="keyword">function</span>(<span class="params">elem, index, arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> elem &gt;= <span class="number">3</span>;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 返回true</span></div></pre></td></tr></table></figure>
<p>上面代码表示，如果存在大于等于3的数组成员，就返回true。</p>
<p>every方法对所有元素调用一个测试函数，只有所有元素通过该测试，才返回true，否则返回false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].every(<span class="function"><span class="keyword">function</span>(<span class="params">elem, index, arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> elem &gt;= <span class="number">3</span>;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 返回false</span></div></pre></td></tr></table></figure>
<p>上面代码表示，只有所有数组成员大于等于3，才返回true。</p>
<p>从上面的代码可以看到，some和every的使用方法与map和forEach是一致的，参数完全一模一样。也就是说，它们也可以使用第二个参数，用来绑定函数中的this关键字。</p>
<h3 id="reduce方法，reduceRight方法"><a href="#reduce方法，reduceRight方法" class="headerlink" title="reduce方法，reduceRight方法"></a>reduce方法，reduceRight方法</h3><p>reduce方法和reduceRight方法的作用，是依次处理数组的每个元素，最终累计为一个值。这两个方法的差别在于，reduce对数组元素的处理顺序是从左到右（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他地方完全一样。</p>
<p>reduce方法的第一个参数是一个处理函数。该函数接受四个参数，分别是：</p>
<ol>
<li>用来累计的变量（即当前状态），默认值为0</li>
<li>数组的当前元素</li>
<li>当前元素在数组中的序号（从0开始）</li>
<li>原数组</li>
</ol>
<p>这四个参数之中，只有前两个是必须的，后两个则是可选的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> x+y;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 15</span></div></pre></td></tr></table></figure>
<p>上面代码的参数x表示累计变量，默认为0，y则是数组的当前元素。reduce方法依次将每个数组元素加入x，最终返回它们的总和15。</p>
<p>利用reduce方法，可以写一个数组求和的sum方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">partial, value</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> partial + value;</div><div class="line">    &#125;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>].sum()</div><div class="line"><span class="comment">// 28</span></div></pre></td></tr></table></figure>
<p>如果要对累计变量指定初值，可以把它放在reduce方法的第二个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> x+y;</div><div class="line">&#125;, <span class="number">10</span>);</div><div class="line"><span class="comment">// 25</span></div></pre></td></tr></table></figure>
<p>上面代码指定参数x的初值为10，所以数组元素从10开始累加，最终结果为25。</p>
<p>由于reduce方法依次处理每个元素，所以实际上还可以用它来搜索某个元素。比如，下面代码是找出长度最长的数组元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLongest</span>(<span class="params">entries</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> entries.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">longest, entry</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> entry.length &gt; longest.length ? entry : longest;</div><div class="line">  &#125;, <span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf 和 lastIndexOf"></a>indexOf 和 lastIndexOf</h3><p>ECMAScript 5新增的9个方法之中，有2个与函数式编程无关，分别是indexOf和lastIndexOf。</p>
<p>indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</div><div class="line"></div><div class="line">a.indexOf(<span class="string">'b'</span>)</div><div class="line"><span class="comment">// 1</span></div><div class="line"></div><div class="line">a.indexOf(<span class="string">'y'</span>)</div><div class="line"><span class="comment">// -1</span></div></pre></td></tr></table></figure>
<p>indexOf方法还可以接受第二个参数，表示搜索的开始位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>].indexOf(<span class="string">'a'</span>, <span class="number">1</span>)</div><div class="line"><span class="comment">// -1</span></div></pre></td></tr></table></figure>
<p>上面代码从位置1开始搜索字符a，结果为-1，表示没有搜索到。</p>
<p>lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>];</div><div class="line"></div><div class="line">a.lastIndexOf(<span class="number">2</span>)</div><div class="line"><span class="comment">// 3</span></div><div class="line"></div><div class="line">a.lastIndexOf(<span class="number">7</span>)</div><div class="line"><span class="comment">// -1</span></div></pre></td></tr></table></figure>
<p>注意，如果数组中包含NaN，这两个方法不适用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></div><div class="line">[<span class="literal">NaN</span>].lastIndexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></div></pre></td></tr></table></figure>
<p>这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。</p>
<h3 id="链式使用"><a href="#链式使用" class="headerlink" title="链式使用"></a>链式使用</h3><p>上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> users = [&#123;name:<span class="string">"tom"</span>, email:<span class="string">"tom@example.com"</span>&#125;,</div><div class="line">			 &#123;name:<span class="string">"peter"</span>, email:<span class="string">"peter@example.com"</span>&#125;];</div><div class="line"></div><div class="line">users</div><div class="line">.map(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>)</span>&#123; <span class="keyword">return</span> user.email; &#125;)</div><div class="line">.filter(<span class="function"><span class="keyword">function</span> (<span class="params">email</span>) </span>&#123; <span class="keyword">return</span> <span class="regexp">/^t/</span>.test(email); &#125;)</div><div class="line">.forEach(alert);</div><div class="line"><span class="comment">// 弹出tom@example.com</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Array是JavaScript的内置对象，同时也是一个构造函数，可以用它生成新的数组。&lt;/p&gt;
&lt;p&gt;作为构造函数时，Array可以接受参数，但是不同的参数，会使得Array产生不同的行为。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.houfeng.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 之 “ArrayBuffer对象”</title>
    <link href="http://blog.houfeng.net/2014/10/15/javascript-arraybuffer/"/>
    <id>http://blog.houfeng.net/2014/10/15/javascript-arraybuffer/</id>
    <published>2014-10-14T16:00:00.000Z</published>
    <updated>2016-08-27T04:28:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>类型化数组是JavaScript操作二进制数据的一个接口。<br>这要从WebGL项目的诞生说起，所谓WebGL，就是指浏览器与显卡之间的通信接口，为了满足JavaScript与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。<br>比如，以文本格式传递一个32位整数，两端的JavaScript脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像C语言那样，直接操作字节，然后将4个字节的32位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。<br>类型化数组（Typed Array）就是在这种背景下诞生的。它很像C语言的数组，允许开发者以数组下标的形式，直接操作内存。有了类型化数组以后，JavaScript的二进制数据处理功能增强了很多，接口之间完全可以用二进制数据通信。</p>
<a id="more"></a>
<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>类型化数组是建立在ArrayBuffer对象的基础上的。它的作用是，分配一段可以存放数据的连续内存区域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">32</span>);</div></pre></td></tr></table></figure>
<p>上面代码生成了一段32字节的内存区域。</p>
<p>ArrayBuffer对象的<strong>byteLength属性</strong>，返回所分配的内存区域的字节长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">32</span>);</div><div class="line">buffer.byteLength</div><div class="line"><span class="comment">// 32</span></div></pre></td></tr></table></figure>
<p>如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (buffer.byteLength === n) &#123;</div><div class="line">  <span class="comment">// 成功</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 失败</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ArrayBuffer对象有一个<strong>slice方法</strong>，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> newBuffer = buffer.slice(<span class="number">0</span>,<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>上面代码拷贝buffer对象的前3个字节，生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。</p>
<p>slice方法接受两个参数，第一个参数表示拷贝开始的字节序号，第二个参数表示拷贝截止的字节序号。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。</p>
<p>除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="视图的生成"><a href="#视图的生成" class="headerlink" title="视图的生成"></a>视图的生成</h3><p>ArrayBuffer作为内存区域，可以存放多种类型的数据。不同数据有不同的存储方式，这就叫做“视图”。目前，JavaScript提供以下类型的视图：</p>
<ul>
<li><strong>Int8Array</strong>：8位有符号整数，长度1个字节。</li>
<li><strong>Uint8Array</strong>：8位无符号整数，长度1个字节。</li>
<li><strong>Int16Array</strong>：16位有符号整数，长度2个字节。</li>
<li><strong>Uint16Array</strong>：16位无符号整数，长度2个字节。</li>
<li><strong>Int32Array</strong>：32位有符号整数，长度4个字节。</li>
<li><strong>Uint32Array</strong>：32位无符号整数，长度4个字节。</li>
<li><strong>Float32Array</strong>：32位浮点数，长度4个字节。</li>
<li><strong>Float64Array</strong>：64位浮点数，长度8个字节。</li>
</ul>
<p>每一种视图都有一个BYTES_PER_ELEMENT常数，表示这种数据类型占据的字节数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Int8Array</span>.BYTES_PER_ELEMENT <span class="comment">// 1</span></div><div class="line"><span class="built_in">Uint8Array</span>.BYTES_PER_ELEMENT <span class="comment">// 1</span></div><div class="line"><span class="built_in">Int16Array</span>.BYTES_PER_ELEMENT <span class="comment">// 2</span></div><div class="line"><span class="built_in">Uint16Array</span>.BYTES_PER_ELEMENT <span class="comment">// 2</span></div><div class="line"><span class="built_in">Int32Array</span>.BYTES_PER_ELEMENT <span class="comment">// 4</span></div><div class="line"><span class="built_in">Uint32Array</span>.BYTES_PER_ELEMENT <span class="comment">// 4</span></div><div class="line"><span class="built_in">Float32Array</span>.BYTES_PER_ELEMENT <span class="comment">// 4</span></div><div class="line"><span class="built_in">Float64Array</span>.BYTES_PER_ELEMENT <span class="comment">// 8</span></div></pre></td></tr></table></figure>
<p>每一种视图都是一个构造函数，有多种方法可以生成：</p>
<p><strong>（1）在ArrayBuffer对象之上生成视图。</strong></p>
<p>同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 创建一个8字节的ArrayBuffer</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾</span></div><div class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(b);</div><div class="line"></div><div class="line"><span class="comment">// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾</span></div><div class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(b, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建一个指向b的Int16视图，开始于字节2，长度为2</span></div><div class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(b, <span class="number">2</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>上面代码在一段长度为8个字节的内存（b）之上，生成了三个视图：v1、v2和v3。视图的构造函数可以接受三个参数：</p>
<ul>
<li>第一个参数：视图对应的底层ArrayBuffer对象，该参数是必需的。</li>
<li>第二个参数：视图开始的字节序号，默认从0开始。</li>
<li>第三个参数：视图包含的数据个数，默认直到本段内存区域结束。</li>
</ul>
<p>因此，v1、v2和v3是重叠：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。</p>
<p><strong>（2）直接生成。</strong></p>
<p>视图还可以不通过ArrayBuffer对象，直接分配内存而生成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> f64a = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="number">8</span>);</div><div class="line">f64a[<span class="number">0</span>] = <span class="number">10</span>;</div><div class="line">f64a[<span class="number">1</span>] = <span class="number">20</span>;</div><div class="line">f64a[<span class="number">2</span>] = f64a[<span class="number">0</span>] + f64a[<span class="number">1</span>];</div></pre></td></tr></table></figure>
<p>上面代码生成一个8个成员的Float64Array数组（共64字节），然后依次对每个成员赋值。这时，视图构造函数的参数就是成员的个数。可以看到，视图数组的赋值操作与普通数组的操作毫无两样。</p>
<p><strong>（3）将普通数组转为视图数组。</strong></p>
<p>将一个数据类型符合要求的普通数组，传入构造函数，也能直接生成视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> typedArray = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ] );</div></pre></td></tr></table></figure>
<p>上面代码将一个普通的数组，赋值给一个新生成的8位无符号整数的视图数组。</p>
<p>视图数组也可以转换回普通数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> normalArray = <span class="built_in">Array</span>.apply( [], typedArray );</div></pre></td></tr></table></figure>
<h3 id="视图的操作"><a href="#视图的操作" class="headerlink" title="视图的操作"></a>视图的操作</h3><p>建立了视图以后，就可以进行各种操作了。这里需要明确的是，视图其实就是普通数组，语法完全没有什么不同，只不过它直接针对内存进行操作，而且每个成员都有确定的数据类型。所以，视图就被叫做“类型化数组”。</p>
<p><strong>（1）数组操作</strong></p>
<p>普通数组的操作方法和属性，对类型化数组完全适用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> int32View = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buffer);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;int32View.length; i++) &#123;</div><div class="line">  int32View[i] = i*<span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码生成一个16字节的ArrayBuffer对象，然后在它的基础上，建立了一个32位整数的视图。由于每个32位整数占据4个字节，所以一共可以写入4个整数，依次为0，2，4，6。</p>
<p>如果在这段数据上接着建立一个16位整数的视图，则可以读出完全不一样的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> int16View = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;int16View.length; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Entry "</span> + i + <span class="string">": "</span> + int16View[i]);</div><div class="line">&#125;</div><div class="line"><span class="comment">// Entry 0: 0</span></div><div class="line"><span class="comment">// Entry 1: 0</span></div><div class="line"><span class="comment">// Entry 2: 2</span></div><div class="line"><span class="comment">// Entry 3: 0</span></div><div class="line"><span class="comment">// Entry 4: 4</span></div><div class="line"><span class="comment">// Entry 5: 0</span></div><div class="line"><span class="comment">// Entry 6: 6</span></div><div class="line"><span class="comment">// Entry 7: 0</span></div></pre></td></tr></table></figure>
<p>由于每个16位整数占据2个字节，所以整个ArrayBuffer对象现在分成8段。然后，由于x86体系的计算机都采用小端字节序（little endian），相对重要的字节排在后面的内存地址，相对不重要字节排在前面的内存地址，所以就得到了上面的结果。</p>
<p>比如，一个占据四个字节的16进制数0x12345678，决定其大小的最重要的字节是“12”，最不重要的是“78”。小端字节序将最不重要的字节排在前面，储存顺序就是78563412；大端字节序则完全相反，将最重要的字节排在前面，储存顺序就是12345678。目前，所有个人电脑几乎都是小端字节序，所以类型化数组内部也采用小端字节序读写数据，或者更准确的说，按照本机操作系统设定的字节序读写数据。</p>
<p>这并不意味大端字节序不重要，事实上，很多网络设备和特定的操作系统采用的是大端字节序。这就带来一个严重的问题：如果一段数据是大端字节序，类型化数组将无法正确解析，因为它只能处理小端字节序！为了解决这个问题，JavaScript引入DataView对象，可以设定字节序，下文会详细介绍。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 假定某段buffer包含如下字节 [0x02, 0x01, 0x03, 0x07]</span></div><div class="line"><span class="comment">// 计算机采用小端字节序</span></div><div class="line"><span class="keyword">var</span> uInt16View = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 比较运算 </span></div><div class="line"><span class="keyword">if</span> (bufView[<span class="number">0</span>]===<span class="number">258</span>) &#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 赋值运算</span></div><div class="line">uInt16View[<span class="number">0</span>] = <span class="number">255</span>;    <span class="comment">// 字节变为[0xFF, 0x00, 0x03, 0x07]</span></div><div class="line">uInt16View[<span class="number">0</span>] = <span class="number">0xff05</span>; <span class="comment">// 字节变为[0x05, 0xFF, 0x03, 0x07]</span></div><div class="line">uInt16View[<span class="number">1</span>] = <span class="number">0x0210</span>; <span class="comment">// 字节变为[0x05, 0xFF, 0x10, 0x02]</span></div></pre></td></tr></table></figure>
<p>总之，与普通数组相比，类型化数组的最大优点就是可以直接操作内存，不需要数据类型转换，所以速度快得多。</p>
<p><strong>（2）buffer属性</strong></p>
<p>类型化数组的buffer属性，返回整段内存区域对应的ArrayBuffer对象。该属性为只读属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">64</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(a.buffer);</div></pre></td></tr></table></figure>
<p>上面代码的a对象和b对象，对应同一个ArrayBuffer对象，即同一段内存。</p>
<p><strong>（3）byteLength属性和byteOffset属性</strong></p>
<p>byteLength属性返回类型化数组占据的内存长度，单位为字节。byteOffset属性返回类型化数组从底层ArrayBuffer对象的哪个字节开始。这两个属性都是只读属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(b);</div><div class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(b, <span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(b, <span class="number">2</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line">v1.byteLength <span class="comment">// 8</span></div><div class="line">v2.byteLength <span class="comment">// 6</span></div><div class="line">v3.byteLength <span class="comment">// 4</span></div><div class="line"></div><div class="line">v1.byteOffset <span class="comment">// 0</span></div><div class="line">v2.byteOffset <span class="comment">// 2</span></div><div class="line">v3.byteOffset <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>注意将byteLength属性和length属性区分，前者是字节长度，后者是成员长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">8</span>);</div><div class="line"></div><div class="line">a.length <span class="comment">// 8</span></div><div class="line">a.byteLength <span class="comment">// 16</span></div></pre></td></tr></table></figure>
<p><strong>（4）set方法</strong></p>
<p>类型化数组的set方法用于复制数组，也就是将一段内容完全复制到另一段内存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">8</span>);</div><div class="line"></div><div class="line">b.set(a);</div></pre></td></tr></table></figure>
<p>上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">10</span>);</div><div class="line"></div><div class="line">b.set(a,<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。</p>
<p><strong>（5）subarray方法</strong></p>
<p>subarray方法是对于类型化数组的一部分，再建立一个新的视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> b = a.subarray(<span class="number">2</span>,<span class="number">3</span>);</div><div class="line"></div><div class="line">a.byteLength <span class="comment">// 16</span></div><div class="line">b.byteLength <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>subarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。</p>
<p><strong>（6）ArrayBuffer与字符串的互相转换</strong></p>
<p>ArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// ArrayBuffer转为字符串，参数为ArrayBuffer对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ab2str</span>(<span class="params">buf</span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode.apply(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buf));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 字符串转为ArrayBuffer对象，参数为字符串</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2ab</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(str.length*<span class="number">2</span>); <span class="comment">// 每个字符占用2个字节</span></div><div class="line">    <span class="keyword">var</span> bufView = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buf);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, strLen=str.length; i&lt;strLen; i++) &#123;</div><div class="line">         bufView[i] = str.charCodeAt(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="复合视图"><a href="#复合视图" class="headerlink" title="复合视图"></a>复合视图</h3><p>由于视图的构造函数可以指定起始位置和长度，所以在同一段内存之中，可以依次存放不同类型的数据，这叫做“复合视图”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">24</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> idView = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(buffer, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> usernameView = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buffer, <span class="number">4</span>, <span class="number">16</span>);</div><div class="line"><span class="keyword">var</span> amountDueView = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(buffer, <span class="number">20</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>上面代码将一个24字节长度的ArrayBuffer对象，分成三个部分：</p>
<ul>
<li>字节0到字节3：1个32位无符号整数</li>
<li>字节4到字节19：16个8位整数</li>
<li>字节20到字节23：1个32位浮点数</li>
</ul>
<p>这种数据结构可以用如下的C语言描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">struct</span> someStruct &#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> id;</div><div class="line">  <span class="keyword">char</span> username[<span class="number">16</span>];</div><div class="line">  <span class="keyword">float</span> amountDue;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="DataView视图"><a href="#DataView视图" class="headerlink" title="DataView视图"></a>DataView视图</h2><p>如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。</p>
<p>DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种类型化视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p>
<p>DataView本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">DataView</span>(<span class="built_in">ArrayBuffer</span> buffer [, 字节起始位置 [, 长度]]);</div></pre></td></tr></table></figure>
<p>下面是一个实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">24</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div></pre></td></tr></table></figure>
<p>DataView视图提供以下方法读取内存：</p>
<ul>
<li><strong>getInt8</strong>：读取1个字节，返回一个8位整数。</li>
<li><strong>getUint8</strong>：读取1个字节，返回一个无符号的8位整数。</li>
<li><strong>getInt16</strong>：读取2个字节，返回一个16位整数。</li>
<li><strong>getUint16</strong>：读取2个字节，返回一个无符号的16位整数。</li>
<li><strong>getInt32</strong>：读取4个字节，返回一个32位整数。</li>
<li><strong>getUint32</strong>：读取4个字节，返回一个无符号的32位整数。</li>
<li><strong>getFloat32</strong>：读取4个字节，返回一个32位浮点数。</li>
<li><strong>getFloat64</strong>：读取8个字节，返回一个64位浮点数。</li>
</ul>
<p>这一系列get方法的参数都是一个字节序号，表示从哪个字节开始读取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">24</span>);</div><div class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 从第1个字节读取一个8位无符号整数</span></div><div class="line"><span class="keyword">var</span> v1 = dv.getUint8(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 从第2个字节读取一个16位无符号整数</span></div><div class="line"><span class="keyword">var</span> v2 = dv.getUint16(<span class="number">1</span>); </div><div class="line"></div><div class="line"><span class="comment">// 从第4个字节读取一个16位无符号整数</span></div><div class="line"><span class="keyword">var</span> v3 = dv.getUint16(<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。</p>
<p>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 小端字节序</span></div><div class="line"><span class="keyword">var</span> v1 = dv.getUint16(<span class="number">1</span>, <span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="comment">// 大端字节序</span></div><div class="line"><span class="keyword">var</span> v2 = dv.getUint16(<span class="number">3</span>, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// 大端字节序</span></div><div class="line"><span class="keyword">var</span> v3 = dv.getUint16(<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>DataView视图提供以下方法写入内存：</p>
<ul>
<li><strong>setInt8</strong>：写入1个字节的8位整数。</li>
<li><strong>setUint8</strong>：写入1个字节的8位无符号整数。</li>
<li><strong>setInt16</strong>：写入2个字节的16位整数。</li>
<li><strong>setUint16</strong>：写入2个字节的16位无符号整数。</li>
<li><strong>setInt32</strong>：写入4个字节的32位整数。</li>
<li><strong>setUint32</strong>：写入4个字节的32位无符号整数。</li>
<li><strong>setFloat32</strong>：写入4个字节的32位浮点数。</li>
<li><strong>setFloat64</strong>：写入8个字节的64位浮点数。</li>
</ul>
<p>这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 在第1个字节，以大端字节序写入值为25的32位整数</span></div><div class="line">dv.setInt32(<span class="number">0</span>, <span class="number">25</span>, <span class="literal">false</span>); </div><div class="line"></div><div class="line"><span class="comment">// 在第5个字节，以大端字节序写入值为25的32位整数</span></div><div class="line">dv.setInt32(<span class="number">4</span>, <span class="number">25</span>); </div><div class="line"></div><div class="line"><span class="comment">// 在第9个字节，以小端字节序写入值为2.5的32位浮点数</span></div><div class="line">dv.setFloat32(<span class="number">8</span>, <span class="number">2.5</span>, <span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> littleEndian = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</div><div class="line">  <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer).setInt16(<span class="number">0</span>, <span class="number">256</span>, <span class="literal">true</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer)[<span class="number">0</span>] === <span class="number">256</span>;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>如果返回true，就是小端字节序；如果返回false，就是大端字节序。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>传统上，服务器通过Ajax操作只能返回文本数据。XMLHttpRequest 第二版允许服务器返回二进制数据，这时分成两种情况。如果明确知道返回的二进制数据类型，可以把返回类型（responseType）设为arraybuffer；如果不知道，就设为blob。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">xhr.responseType = <span class="string">'arraybuffer'</span>;</div></pre></td></tr></table></figure>
<p>如果知道传回来的是32位整数，可以像下面这样处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (req.readyState === <span class="number">4</span> ) &#123;</div><div class="line">    <span class="keyword">var</span> arrayResponse = xhr.response;</div><div class="line">    <span class="keyword">var</span> dataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(arrayResponse);</div><div class="line">    <span class="keyword">var</span> ints = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(dataView.byteLength / <span class="number">4</span>);</div><div class="line"></div><div class="line">    xhrDiv.style.backgroundColor = <span class="string">"#00FF00"</span>;</div><div class="line">    xhrDiv.innerText = <span class="string">"Array is "</span> + ints.length + <span class="string">"uints long"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>网页Canvas元素输出的二进制像素数据，就是类型化数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</div><div class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> imageData = ctx.getImageData(<span class="number">0</span>,<span class="number">0</span>, <span class="number">200</span>, <span class="number">100</span>);</div><div class="line"><span class="keyword">var</span> typedArray = imageData.data;</div></pre></td></tr></table></figure>
<p>需要注意的是，上面代码的typedArray虽然是一个类型化数组，但是它的视图类型是一种针对Canvas元素的专有类型Uint8ClampedArray。这个视图类型的特点，就是专门针对颜色，把每个字节解读为无符号的8位整数，即只能取值0～255，而且发生运算的时候自动过滤高位溢出。这为图像处理带来了巨大的方便。</p>
<p>举例来说，如果把像素的颜色值设为Uint8Array类型，那么乘以一个gamma值的时候，就必须这样计算：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">u8[i] = <span class="built_in">Math</span>.min(<span class="number">255</span>, <span class="built_in">Math</span>.max(<span class="number">0</span>, u8[i] * gamma));</div></pre></td></tr></table></figure>
<p>因为Uint8Array类型对于大于255的运算结果（比如0xFF+1），会自动变为0x00，所以图像处理必须要像上面这样算。这样做很麻烦，而且影响性能。如果将颜色值设为Uint8ClampedArray类型，计算就简化许多。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">pixels[i] *= gamma;</div></pre></td></tr></table></figure>
<p>Uint8ClampedArray类型确保将小于0的值设为0，将大于255的值设为255。注意，IE 10不支持该类型。</p>
<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>如果知道一个文件的二进制数据类型，也可以将这个文件读取为类型化数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">reader.readAsArrayBuffer(file);</div></pre></td></tr></table></figure>
<p>下面以处理bmp文件为例。假定file变量是一个指向bmp文件的文件对象，首先读取文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</div><div class="line">reader.addEventListener(<span class="string">"load"</span>, processimage, <span class="literal">false</span>); </div><div class="line">reader.readAsArrayBuffer(file);</div></pre></td></tr></table></figure>
<p>然后，定义处理图像的回调函数：先在二进制数据之上建立一个DataView视图，再建立一个bitmap对象，用于存放处理后的数据，最后将图像展示在canvas元素之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processimage</span>(<span class="params">e</span>) </span>&#123; </div><div class="line"> <span class="keyword">var</span> buffer = e.target.result; </div><div class="line"> <span class="keyword">var</span> datav = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer); </div><div class="line"> <span class="keyword">var</span> bitmap = &#123;&#125;;</div><div class="line"> <span class="comment">// 具体的处理步骤</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体处理图像数据时，先处理bmp的文件头。具体每个文件头的格式和定义，请参阅有关资料。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">bitmap.fileheader = &#123;&#125;; </div><div class="line">bitmap.fileheader.bfType = datav.getUint16(<span class="number">0</span>, <span class="literal">true</span>); </div><div class="line">bitmap.fileheader.bfSize = datav.getUint32(<span class="number">2</span>, <span class="literal">true</span>); </div><div class="line">bitmap.fileheader.bfReserved1 = datav.getUint16(<span class="number">6</span>, <span class="literal">true</span>); </div><div class="line">bitmap.fileheader.bfReserved2 = datav.getUint16(<span class="number">8</span>, <span class="literal">true</span>); </div><div class="line">bitmap.fileheader.bfOffBits = datav.getUint32(<span class="number">10</span>, <span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>接着处理图像元信息部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">bitmap.infoheader = &#123;&#125;;</div><div class="line">bitmap.infoheader.biSize = datav.getUint32(<span class="number">14</span>, <span class="literal">true</span>);</div><div class="line">bitmap.infoheader.biWidth = datav.getUint32(<span class="number">18</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biHeight = datav.getUint32(<span class="number">22</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biPlanes = datav.getUint16(<span class="number">26</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biBitCount = datav.getUint16(<span class="number">28</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biCompression = datav.getUint32(<span class="number">30</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biSizeImage = datav.getUint32(<span class="number">34</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biXPelsPerMeter = datav.getUint32(<span class="number">38</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biYPelsPerMeter = datav.getUint32(<span class="number">42</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biClrUsed = datav.getUint32(<span class="number">46</span>, <span class="literal">true</span>); </div><div class="line">bitmap.infoheader.biClrImportant = datav.getUint32(<span class="number">50</span>, <span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>最后处理图像本身的像素信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> start = bitmap.fileheader.bfOffBits;</div><div class="line">bitmap.pixels = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buffer, start);</div></pre></td></tr></table></figure>
<p>至此，图像文件的数据全部处理完成。下一步，可以根据需要，进行图像变形，或者转换格式，或者展示在Canvas网页元素之中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类型化数组是JavaScript操作二进制数据的一个接口。&lt;br&gt;这要从WebGL项目的诞生说起，所谓WebGL，就是指浏览器与显卡之间的通信接口，为了满足JavaScript与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。&lt;br&gt;比如，以文本格式传递一个32位整数，两端的JavaScript脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像C语言那样，直接操作字节，然后将4个字节的32位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。&lt;br&gt;类型化数组（Typed Array）就是在这种背景下诞生的。它很像C语言的数组，允许开发者以数组下标的形式，直接操作内存。有了类型化数组以后，JavaScript的二进制数据处理功能增强了很多，接口之间完全可以用二进制数据通信。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.houfeng.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 之 “Math对象”</title>
    <link href="http://blog.houfeng.net/2014/07/15/javascript-math/"/>
    <id>http://blog.houfeng.net/2014/07/15/javascript-math/</id>
    <published>2014-07-14T16:00:00.000Z</published>
    <updated>2016-08-27T04:29:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Math对象是JavaScript的内置对象，提供一系列数学常数和数学方法。</p>
<p>该对象不是构造函数，所以不能生成实例，所有的属性和方法都必须在Math对象上调用。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Math</span>()</div><div class="line"><span class="comment">// TypeError: object is not a function</span></div></pre></td></tr></table></figure>
<p>上面代码表示，Math不能当作构造函数用。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>Math对象提供以下一些只读的数学常数。</p>
<ul>
<li>E：常数e。</li>
<li>LN2：2的自然对数。</li>
<li>LN10：10的自然对数。</li>
<li>LOG2E：以2为底的e的对数。</li>
<li>LOG10E：以10为底的e的对数。</li>
<li>PI：常数Pi。</li>
<li>SQRT1_2：0.5的平方根。</li>
<li>SQRT2：2的平方根。</li>
</ul>
<p>这些常数的值如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.E <span class="comment">// 2.718281828459045</span></div><div class="line"><span class="built_in">Math</span>.LN2 <span class="comment">// 0.6931471805599453</span></div><div class="line"><span class="built_in">Math</span>.LN10 <span class="comment">// 2.302585092994046</span></div><div class="line"><span class="built_in">Math</span>.LOG2E <span class="comment">// 1.4426950408889634</span></div><div class="line"><span class="built_in">Math</span>.LOG10E <span class="comment">// 0.4342944819032518</span></div><div class="line"><span class="built_in">Math</span>.PI <span class="comment">// 3.141592653589793</span></div><div class="line"><span class="built_in">Math</span>.SQRT1_2 <span class="comment">// 0.7071067811865476</span></div><div class="line"><span class="built_in">Math</span>.SQRT2 <span class="comment">// 1.4142135623730951</span></div></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Math对象提供以下一些数学方法。</p>
<h3 id="round方法"><a href="#round方法" class="headerlink" title="round方法"></a>round方法</h3><p>round方法用于四舍五入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.round(<span class="number">0.1</span>) <span class="comment">// 0</span></div><div class="line"><span class="built_in">Math</span>.round(<span class="number">0.5</span>) <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>它对于负值的运算结果与正值略有不同，主要体现在对.5的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.round(<span class="number">-1.1</span>) <span class="comment">// -1</span></div><div class="line"><span class="built_in">Math</span>.round(<span class="number">-1.5</span>) <span class="comment">// -1</span></div></pre></td></tr></table></figure>
<h3 id="abs方法，max方法，min方法"><a href="#abs方法，max方法，min方法" class="headerlink" title="abs方法，max方法，min方法"></a>abs方法，max方法，min方法</h3><p>abs方法返回参数值的绝对值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.abs(<span class="number">1</span>) <span class="comment">// 1</span></div><div class="line"><span class="built_in">Math</span>.abs(<span class="number">-1</span>) <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>max方法返回最大的参数，min方法返回最小的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.max(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">5</span>) <span class="comment">// 5</span></div><div class="line"><span class="built_in">Math</span>.min(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">5</span>) <span class="comment">// -1</span></div></pre></td></tr></table></figure>
<h3 id="floor方法，ceil方法"><a href="#floor方法，ceil方法" class="headerlink" title="floor方法，ceil方法"></a>floor方法，ceil方法</h3><p>floor方法返回小于参数值的最大整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.floor(<span class="number">3.2</span>) <span class="comment">// 3</span></div><div class="line"><span class="built_in">Math</span>.floor(<span class="number">-3.2</span>) <span class="comment">// -4</span></div></pre></td></tr></table></figure>
<p>ceil方法返回大于参数值的最小整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.ceil(<span class="number">3.2</span>) <span class="comment">// 4</span></div><div class="line"><span class="built_in">Math</span>.ceil(<span class="number">-3.2</span>) <span class="comment">// -3</span></div></pre></td></tr></table></figure>
<h3 id="pow方法，sqrt方法"><a href="#pow方法，sqrt方法" class="headerlink" title="pow方法，sqrt方法"></a>pow方法，sqrt方法</h3><p>power方法返回以第一个参数为底数、第二个参数为幂的指数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>) <span class="comment">// 4</span></div><div class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 8</span></div></pre></td></tr></table></figure>
<p>sqrt方法法返回参数值的平方根。如果参数是一个负值，则返回NaN。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.sqrt(<span class="number">4</span>) <span class="comment">// 2</span></div><div class="line"><span class="built_in">Math</span>.sqrt(<span class="number">-4</span>) <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
<h3 id="log方法，exp方法"><a href="#log方法，exp方法" class="headerlink" title="log方法，exp方法"></a>log方法，exp方法</h3><p>log方法返回以e为底的自然对数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.log(<span class="built_in">Math</span>.E) <span class="comment">// 1</span></div><div class="line"><span class="built_in">Math</span>.log(<span class="number">10</span>) <span class="comment">// 2.302585092994046</span></div></pre></td></tr></table></figure>
<p>求以10为底的对数，可以除以Math.LN10；求以2为底的对数，可以除以Math.LN2。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.log(<span class="number">100</span>)/<span class="built_in">Math</span>.LN10 <span class="comment">// 2</span></div><div class="line"><span class="built_in">Math</span>.log(<span class="number">8</span>)/<span class="built_in">Math</span>.LN2 <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>exp方法返回常数e的参数次方。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.exp(<span class="number">1</span>) <span class="comment">// 2.718281828459045</span></div><div class="line"><span class="built_in">Math</span>.exp(<span class="number">3</span>) <span class="comment">// 20.085536923187668</span></div></pre></td></tr></table></figure>
<h3 id="random方法"><a href="#random方法" class="headerlink" title="random方法"></a>random方法</h3><p>该方法返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.random() <span class="comment">// 0.7151307314634323</span></div><div class="line"></div><div class="line"><span class="comment">// 返回给定范围内的随机数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomArbitrary</span>(<span class="params">min, max</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() * (max - min) + min;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 返回给定范围内的随机整数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomInt</span>(<span class="params">min, max</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h3><p>sin方法返回参数的正弦，cos方法返回参数的余弦，tan方法返回参数的正切。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.sin(<span class="number">0</span>) <span class="comment">// 0</span></div><div class="line"><span class="built_in">Math</span>.cos(<span class="number">0</span>) <span class="comment">// 1</span></div><div class="line"><span class="built_in">Math</span>.tan(<span class="number">0</span>) <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p>asin方法返回参数的反正弦，acos方法返回参数的反余弦，atan方法返回参数的反正切。这个三个方法的返回值都是弧度值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.asin(<span class="number">1</span>) <span class="comment">// 1.5707963267948966</span></div><div class="line"><span class="built_in">Math</span>.acos(<span class="number">1</span>) <span class="comment">// 0</span></div><div class="line"><span class="built_in">Math</span>.atan(<span class="number">1</span>) <span class="comment">// 0.7853981633974483</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Math对象是JavaScript的内置对象，提供一系列数学常数和数学方法。&lt;/p&gt;
&lt;p&gt;该对象不是构造函数，所以不能生成实例，所有的属性和方法都必须在Math对象上调用。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.houfeng.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB 高可用群集简单配置</title>
    <link href="http://blog.houfeng.net/2013/10/26/mongodb-replica-set/"/>
    <id>http://blog.houfeng.net/2013/10/26/mongodb-replica-set/</id>
    <published>2013-10-25T16:00:00.000Z</published>
    <updated>2016-08-27T04:29:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Replica-Set-节点类型分为三种："><a href="#Replica-Set-节点类型分为三种：" class="headerlink" title="Replica Set 节点类型分为三种："></a>Replica Set 节点类型分为三种：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">standard：常规节点，它存储一份完整的数据副本，参与选举投票，有可能成为primary节点。</div><div class="line">passive：存储了完整的数据副本，参与投票，不能成为primary节点。 </div><div class="line">arbiter：仲裁节点，只参与投票，不接收复制的数据，也不能成为primary节点。</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="节点规划"><a href="#节点规划" class="headerlink" title="节点规划"></a>节点规划</h3><p>仅做的测试而已，所以所有节点仅是同一台服务器上的三个不同端口的 MongoDB 实例，本文配置使用2个常规节点和一个arbiter节点，arbiter节点由于不同步数据，所以负载会很小，部署对硬件没有太大的要求，<br>因为 MongoDB Replica Set 不允许添加两个 “本地（localhost或127.0.01）节点”，所有首先在系统的 hosts 文件中添加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">127.0.0.1 mongodb27021</div><div class="line">127.0.0.1 mongodb27022</div><div class="line">127.0.0.1 mongodb27023</div></pre></td></tr></table></figure>
<p>节点规划如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mongodb27021:27021 主节点(Primary)</div><div class="line">mongodb27022:27022  从节点(Secondary)</div><div class="line">mongodb27023:27023 仲裁节点(Arbiter)</div></pre></td></tr></table></figure>
<h3 id="启动三个节点"><a href="#启动三个节点" class="headerlink" title="启动三个节点"></a>启动三个节点</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod.exe --port=27021 --replSet=rs_test --dbpath=<span class="string">"..\27021\data"</span> --logpath=<span class="string">"..\27021\log\mongodb.log"</span> --smallfiles</div></pre></td></tr></table></figure>
<p>其它两个节点用同样的命令，将端口替换为指定的端口，及指定合适的数据库文件及日志存储目录，生产环境，可将 mongodb 安装到系统服务中（很简单 google 一下吧）。</p>
<h3 id="配置群集"><a href="#配置群集" class="headerlink" title="配置群集"></a>配置群集</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongo -port 27021</div></pre></td></tr></table></figure>
<p>连接到其中一个节点。</p>
<h5 id="初始化群集"><a href="#初始化群集" class="headerlink" title="初始化群集:"></a>初始化群集:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rs.initiate()</div></pre></td></tr></table></figure>
<p>这个命令可以接收参数，直接配置群集中的各节点，这里简单点直接初始化，27021将成为 Primary 节点。</p>
<h5 id="添加从节点"><a href="#添加从节点" class="headerlink" title="添加从节点"></a>添加从节点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rs.add(<span class="string">"mongodb27022:27022"</span>)</div></pre></td></tr></table></figure>
<p>默认从节点的数据不可 “读写” ，连接到从节点，执行 “rs.salveOk()” 可以使从节点只读，以减少主节点的读压力。</p>
<h4 id="添加仲裁节点"><a href="#添加仲裁节点" class="headerlink" title="添加仲裁节点"></a>添加仲裁节点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rs.addArb(<span class="string">"mongodb27022:27023"</span>)</div></pre></td></tr></table></figure>
<p>仲裁节点，不存储数据，只在主节点发生故障时，参与主节点的 “推举”。</p>
<p>至此一个最简单的 Replica Set 高可用群集配置完成。</p>
<h3 id="检查群集"><a href="#检查群集" class="headerlink" title="检查群集"></a>检查群集</h3><ol>
<li>在主节点接入数据，在从节点即可到刚刚接入的数据。</li>
<li>结束到主节点，再连接到从节点用 “rs.isMaster()” 可以看到从节点，已被“推举”为主节点了。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Replica-Set-节点类型分为三种：&quot;&gt;&lt;a href=&quot;#Replica-Set-节点类型分为三种：&quot; class=&quot;headerlink&quot; title=&quot;Replica Set 节点类型分为三种：&quot;&gt;&lt;/a&gt;Replica Set 节点类型分为三种：&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;standard：常规节点，它存储一份完整的数据副本，参与选举投票，有可能成为primary节点。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;passive：存储了完整的数据副本，参与投票，不能成为primary节点。 &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;arbiter：仲裁节点，只参与投票，不接收复制的数据，也不能成为primary节点。&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://blog.houfeng.net/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>模块的封装与解耦</title>
    <link href="http://blog.houfeng.net/2013/03/16/module-encapsulation-decoupling/"/>
    <id>http://blog.houfeng.net/2013/03/16/module-encapsulation-decoupling/</id>
    <published>2013-03-15T16:00:00.000Z</published>
    <updated>2016-08-27T04:29:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="话题起因"><a href="#话题起因" class="headerlink" title="话题起因"></a>话题起因</h3><p>回头看自已写过东西，常会感觉到不满意，总有重构冲动（其实这种冲动通常是好事，因为只有发现了不足才有重构想法，只有重构才能改进，只有改进才能完善）。</p>
<a id="more"></a>
<p>最近，准备重构<a href="http://houfeng/mokit" target="_blank" rel="external">mokit</a>，因为这前的mokit虽然有将不同的“模块”分离在不同的文件中，并有“命名空间”概念，但其实现在版本的mokit模块甚至不能称为真正的模块，因为它没有完整“封装”的概念，并且虽有“命名空间”，但还是会创建一部分全局变量，只能依靠开发人员制定好的“契约”，既“非强制约束”的开发规范。</p>
<p>因为现有mokit存在的各种不足，在重构之前一直在思考mokit更合适的结构：</p>
<ol>
<li>更加清析的、真正的模块化的结构；</li>
<li>模块的真正封装；</li>
<li>模块间的最大化解耦；</li>
<li>更加清析的MVC或MVP模式；</li>
</ol>
<p>第一步先实现真的模块封装，及模块中的解耦，第二步实现简洁易用的MVC或MVP的架构及开框架。MVC稍后再谈，这篇博文将就模块化、封装、解耦做一些控讨。</p>
<h3 id="模块的封装"><a href="#模块的封装" class="headerlink" title="模块的封装"></a>模块的封装</h3><h3 id="百度百科"><a href="#百度百科" class="headerlink" title="##百度百科:"></a>##百度百科:</h3><p>模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性<br>模块化是一种处理复杂系统分解为更好的可管理模块的方式。</p>
<p>模块化用来分割，组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能。<br>模块具有以下几种基本属性：接口、功能、逻辑、状态，功能、状态与接口反映模块的外部特性，逻辑反映它的内部特性。<br>在系统的结构中，模块是可组合、分解和更换的单元。模块化是一种处理复杂系统分解成为更好的可管理模块的方式。它可以通过在不同组件设定不同的功能，把一个问题分解成多个小的独立、互相作用的组件，来处理复杂、大型的软件。</p>
<h3 id="实现模块封装"><a href="#实现模块封装" class="headerlink" title="##实现模块封装:"></a>##实现模块封装:</h3><p>在完整面向对象的语言中可能是一个类，封装作为OOP三大特性：封装、多态、继承之一，在这些有完整OOP机制的语言实现模块的封装非常容易</p>
<p>如在C#中</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">string</span> Ident&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在C#中，一个类（模块）可以方便的声明“私有成员”，实现封装特性；</p>
<p>而在JavaScript中实现就稍显“麻烦”，而且写法是各种各样，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Module1=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> ident=<span class="string">""</span>;</div><div class="line">	<span class="keyword">var</span> name=<span class="string">""</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">    	getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        	<span class="keyword">return</span> name;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>上边在JavaScript的自执行函数中，通过var定议的变量，在函数外部不能被访问也实现了封装。<br>事实上，JavaScript的有很多模块化的库，能够实现更加完整的模块定义，如RequireJS、EmsJs。</p>
<h3 id="模块的依赖"><a href="#模块的依赖" class="headerlink" title="模块的依赖"></a>模块的依赖</h3><p>当程序采用模块化的结构后，不同的功能都分布在不同的模块中，必然存在模块相互调用的问题，这时就需要管理好模块之间的依赖关系；</p>
<p>依赖常常表直观的表现为：</p>
<ol>
<li>在一个包中import另一个包；</li>
<li>在一个类中调用另一个类或存在加一个类的引用；</li>
<li>在一个js文件中用别一个js文件中定议的对象或函数；</li>
</ol>
<p>如在C#中：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> calss A</div><div class="line">&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span> A _a=<span class="keyword">new</span> A();</div><div class="line">	<span class="keyword">public</span> A a</div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">get</span></div><div class="line">        &#123;</div><div class="line">        	<span class="keyword">return</span> _a;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上代码类“B”事实上对类“A”存在“依赖”，在没有A的时候，B是不完整的，是无法使用的；当要替换A的时候需重新编写B，这样其实A、B之间的“耦合”非常高。</p>
<p>这里是假设每一个类就是一个模块，其实，上有时模块的粒度不能到一个类一个模块，我们也不需要每一个类都要“解耦”，但是上边的示例代码，却能“高耦合”的代码带的的问题；</p>
<p>我曾见过一定情况下很“二”的写法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IA</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span> : <span class="title">IA</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span> IA _a=<span class="keyword">new</span> A();</div><div class="line">	<span class="keyword">public</span> IA a</div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">get</span></div><div class="line">        &#123;</div><div class="line">        	<span class="keyword">return</span> _a;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span>&#123;</div><div class="line">        	_a=<span class="keyword">value</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，或许写代码的人一定是想用interface实现A、B间的“解耦”，实际上还不到位，B对A的依赖依然存在，没有任何意义；</p>
<h3 id="模块间的解耦"><a href="#模块间的解耦" class="headerlink" title="模块间的解耦"></a>模块间的解耦</h3><h3 id="依赖反转"><a href="#依赖反转" class="headerlink" title="##依赖反转:"></a>##依赖反转:</h3><p>在面向对象编程领域中，依赖反转原则（Dependency inversion principle）指代了一种特定的解耦（传统的依赖关系建立在高层次上，而具体的策略设置则应用在低层次的模块上）形式。在这种形势下，为了使得高层次的模块不依赖于低层次的模块的实现细节的目的，依赖模块被颠倒了（例如：反转）。该原则规定：<br>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。<br>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。<br>该原则颠倒了一部分人对于面向对象设计的认识方式，比如高层次和低层次对象都应该应该依赖于相同的抽象接口</p>
<p>改掉这很“二”的写法，如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IA</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span> : <span class="title">IA</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span> IA _a=<span class="literal">null</span>;</div><div class="line">	<span class="keyword">public</span> IA a</div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">get</span></div><div class="line">        &#123;</div><div class="line">        	<span class="keyword">if</span>(_a==<span class="literal">null</span>)</div><div class="line">            &#123;</div><div class="line">            	<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"IA没有找到"</span>);</div><div class="line">            &#125;</div><div class="line">        	<span class="keyword">return</span> _a;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span>&#123;</div><div class="line">        	_a=<span class="keyword">value</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这B、A没有强制依赖了，在更换A的时间，也无须动B中的代码，或许我们是用B前的某一个地主将IA的一个实现类实例传给了B，也有可能是基于配置文件及“反射”完成的。</p>
<p>比如，一个插件式的应用程序！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;话题起因&quot;&gt;&lt;a href=&quot;#话题起因&quot; class=&quot;headerlink&quot; title=&quot;话题起因&quot;&gt;&lt;/a&gt;话题起因&lt;/h3&gt;&lt;p&gt;回头看自已写过东西，常会感觉到不满意，总有重构冲动（其实这种冲动通常是好事，因为只有发现了不足才有重构想法，只有重构才能改进，只有改进才能完善）。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://blog.houfeng.net/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>回忆“Adobe　Web创意训练营第一期”</title>
    <link href="http://blog.houfeng.net/2013/01/24/adobe-web-html5/"/>
    <id>http://blog.houfeng.net/2013/01/24/adobe-web-html5/</id>
    <published>2013-01-23T16:00:00.000Z</published>
    <updated>2016-08-27T04:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回忆“Adobe-Web创意训练营第一期”"><a href="#回忆“Adobe-Web创意训练营第一期”" class="headerlink" title="回忆“Adobe　Web创意训练营第一期”"></a>回忆“Adobe　Web创意训练营第一期”</h3><p>说是回忆，其实也就是昨天的事儿。</p>
<p>过去一年，才是回忆，我、我所在的团队主要的工作，就是基于HTML5的移动App开发，我们为我们的两家客户基于HTML5分别开发两个完整的“差旅类”的App。</p>
<ol>
<li>CWT Online China</li>
<li>差旅随行</li>
</ol>
<a id="more"></a>
<hr>
<p>对于HTML5的Webapp的开发从简单了解到较为深入的理解，这个过程我们遇到了不少的问题；我们尝试用巧秒的当然也拙劣的方式去试图解决遇到的每一个问题，实现我们认为很有趣儿、好玩的小创意或常规功能；</p>
<p>当然还会有些问题，在一定条件下似乎是无解的或真的无解的，比如“安卓系统的HTMML5的性能问题”；带着疑问和中霏同学去了”Adobe Web 创意训练营第一期”；</p>
<p>实话说，昨儿的讲座，并没有解决我的问题；</p>
<p>但是，之前我现在所在的这团队，可以称之为”闭门造车”（不表示我们造的”车“不好，相反或许还挺棒）；但总有一种疑虑，去怀疑我们的做法是否正确？是否有更好的做法？</p>
<p>所以，想去看看，别的团队是如何做的；去和其它做同样事儿的一群人，去交流，去切磋，去学习；</p>
<p>我们或者我，也很乐于和对前端、前沿技术有兴趣的同志们，一道高讨论有趣、好玩的东西；</p>
<p>这是本此活动对我来说比较重要的一个意义；也是我们继续参加接下来活动的重要的理由；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;回忆“Adobe-Web创意训练营第一期”&quot;&gt;&lt;a href=&quot;#回忆“Adobe-Web创意训练营第一期”&quot; class=&quot;headerlink&quot; title=&quot;回忆“Adobe　Web创意训练营第一期”&quot;&gt;&lt;/a&gt;回忆“Adobe　Web创意训练营第一期”&lt;/h3&gt;&lt;p&gt;说是回忆，其实也就是昨天的事儿。&lt;/p&gt;
&lt;p&gt;过去一年，才是回忆，我、我所在的团队主要的工作，就是基于HTML5的移动App开发，我们为我们的两家客户基于HTML5分别开发两个完整的“差旅类”的App。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CWT Online China&lt;/li&gt;
&lt;li&gt;差旅随行&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="闲谈" scheme="http://blog.houfeng.net/categories/%E9%97%B2%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器页面渲染之“reflow”</title>
    <link href="http://blog.houfeng.net/2012/12/27/browser-page-reflow/"/>
    <id>http://blog.houfeng.net/2012/12/27/browser-page-reflow/</id>
    <published>2012-12-26T16:00:00.000Z</published>
    <updated>2016-08-27T04:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构（geometries）的进程叫做 reflow（回流）。有时 reflow 页面中的一个元素会 reflow 它的祖先元素以及所有子元素。<br>由于 reflow 的开销非常之大，因此要尽可能的避免 reflow 的发生。</p>
<a id="more"></a>
<h3 id="产生-reflow-的原因"><a href="#产生-reflow-的原因" class="headerlink" title="产生 reflow 的原因"></a>产生 reflow 的原因</h3><ol>
<li>调整窗口大小；</li>
<li>改变字体；</li>
<li>增加或者移除样式表；</li>
<li>内容变化，比如用户在 input 框中输入文字；</li>
<li>激活 CSS 伪类，比如 :hover (IE 中为兄弟结点伪类的激活)；</li>
<li>操作 class 属性；</li>
<li>脚本操作 DOM；</li>
<li>计算 offsetWidth 和 offsetHeight 属性；</li>
<li>设置 style 属性的值。</li>
</ol>
<h3 id="如何减少-reflow"><a href="#如何减少-reflow" class="headerlink" title="如何减少 reflow"></a>如何减少 reflow</h3><ol>
<li>如果想设定元素的样式，通过改变元素的 class 名 (尽可能在 DOM 树的最里层)；</li>
<li>避免设置多项内联样式；</li>
<li>用于表现动画的元素，使用 position 属性的 fixed 值或 absolute 值（脱离文档流）；</li>
<li>权衡平滑和速度（调大每帧间隔，减少 reflow 次数）；</li>
<li>避免使用 table 布局；</li>
<li>避免使用CSS的 JavaScript 表达式 (仅 IE 浏览器)；</li>
<li>减少不必要的 DOM 层级，改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点；</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构（geometries）的进程叫做 reflow（回流）。有时 reflow 页面中的一个元素会 reflow 它的祖先元素以及所有子元素。&lt;br&gt;由于 reflow 的开销非常之大，因此要尽可能的避免 reflow 的发生。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.houfeng.net/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>mac系统如何显示和隐藏文件</title>
    <link href="http://blog.houfeng.net/2012/12/06/mac-show-all-files/"/>
    <id>http://blog.houfeng.net/2012/12/06/mac-show-all-files/</id>
    <published>2012-12-05T16:00:00.000Z</published>
    <updated>2016-08-27T04:30:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mac系统如何显示和隐藏文件"><a href="#mac系统如何显示和隐藏文件" class="headerlink" title="mac系统如何显示和隐藏文件"></a>mac系统如何显示和隐藏文件</h3><p>苹果Mac OS X操作系统下，隐藏文件是否显示有很多种设置方法，最简单的要算在Mac终端输入命令。显示/隐藏Mac隐藏文件命令如下(注意其中的空格并且区分大小写)：   </p>
<a id="more"></a>
<p>显示Mac隐藏文件的命令：defaults write com.apple.finder AppleShowAllFiles -bool true</p>
<p>隐藏Mac隐藏文件的命令：defaults write com.apple.finder AppleShowAllFiles -bool false</p>
<p>或者</p>
<p>显示Mac隐藏文件的命令：defaults write com.apple.finder AppleShowAllFiles  YES</p>
<p>隐藏Mac隐藏文件的命令：defaults write com.apple.finder AppleShowAllFiles  NO</p>
<p>输完单击Enter键，退出终端，重新启动Finder就可以了</p>
<p>重启Finder：鼠标单击窗口左上角的苹果标志–&gt;强制退出–&gt;Finder–&gt;重新启动</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;mac系统如何显示和隐藏文件&quot;&gt;&lt;a href=&quot;#mac系统如何显示和隐藏文件&quot; class=&quot;headerlink&quot; title=&quot;mac系统如何显示和隐藏文件&quot;&gt;&lt;/a&gt;mac系统如何显示和隐藏文件&lt;/h3&gt;&lt;p&gt;苹果Mac OS X操作系统下，隐藏文件是否显示有很多种设置方法，最简单的要算在Mac终端输入命令。显示/隐藏Mac隐藏文件命令如下(注意其中的空格并且区分大小写)：   &lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>如何制作越狱版本iOS软件</title>
    <link href="http://blog.houfeng.net/2012/10/20/How-to-make-escape-version-IOS-software/"/>
    <id>http://blog.houfeng.net/2012/10/20/How-to-make-escape-version-IOS-software/</id>
    <published>2012-10-19T16:00:00.000Z</published>
    <updated>2016-08-27T04:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何制作一个越狱版本的ios应用？"><a href="#如何制作一个越狱版本的ios应用？" class="headerlink" title="如何制作一个越狱版本的ios应用？"></a>如何制作一个越狱版本的ios应用？</h3><ol>
<li>编译生成Distribution版本的程序</li>
<li>右击生成的程序，选择显示包内容，选择Info.plist文件添加字段：SigerIdentity，字段值：Apple OS Application Signing</li>
<li>创建Payload文件夹，将程序拖进，压缩并更改压缩后缀为*.ipa</li>
<li>拖进生成的ipa文件于iTurns或通过同步工具安装即可</li>
</ol>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何制作一个越狱版本的ios应用？&quot;&gt;&lt;a href=&quot;#如何制作一个越狱版本的ios应用？&quot; class=&quot;headerlink&quot; title=&quot;如何制作一个越狱版本的ios应用？&quot;&gt;&lt;/a&gt;如何制作一个越狱版本的ios应用？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;编译生成Distribution版本的程序&lt;/li&gt;
&lt;li&gt;右击生成的程序，选择显示包内容，选择Info.plist文件添加字段：SigerIdentity，字段值：Apple OS Application Signing&lt;/li&gt;
&lt;li&gt;创建Payload文件夹，将程序拖进，压缩并更改压缩后缀为*.ipa&lt;/li&gt;
&lt;li&gt;拖进生成的ipa文件于iTurns或通过同步工具安装即可&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>最快,最简洁的javascript模板引擎jtp</title>
    <link href="http://blog.houfeng.net/2012/10/13/fast-javascript-template-engine-jtp/"/>
    <id>http://blog.houfeng.net/2012/10/13/fast-javascript-template-engine-jtp/</id>
    <published>2012-10-12T16:00:00.000Z</published>
    <updated>2016-08-27T04:30:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="欢迎来到jtp的世界"><a href="#欢迎来到jtp的世界" class="headerlink" title="欢迎来到jtp的世界"></a>欢迎来到jtp的世界</h3><blockquote>
<p>欢迎使用jtp! 最轻量，简洁，高效的javascript模板引擎！<br>如同“jtp”的名字，“轻量、简洁、高效”是jtp的哲学！</p>
</blockquote>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ 轻量，jtp是目前能见到最轻量的javascript模板引擎，只有一个不足1.5k的文件。</div><div class="line">+ 简洁，jtp的语法非常简单，对于一个熟悉html、js的开发人员来说学习难度为0。</div><div class="line">+ 高效，jtp支持模板预编译，快于任何一个你所见过的javascript模板引擎。</div><div class="line">+ 另外，jtp同时支持在浏览器环境使用及服务端javascript环境(Node.js)使用。</div></pre></td></tr></table></figure>
<h3 id="许可协议"><a href="#许可协议" class="headerlink" title="许可协议"></a>许可协议</h3><blockquote>
<p><a href="http://www.gnu.org/licenses/lgpl.html" target="_blank" rel="external">使用jtp请您遵守LGPL协议，否则您将会被起诉。（点击可查看LGPL协议）</a></p>
</blockquote>
<h3 id="在线demo"><a href="#在线demo" class="headerlink" title="在线demo"></a>在线demo</h3><blockquote>
<p><a href="http://code.houfeng.net/demos/jtp/" target="_blank" rel="external">体验在线demo</a></p>
</blockquote>
<h3 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ 您可以发邮件到 admin@xhou.net</div><div class="line">+ 或者访问 http://www.houfeng.net</div><div class="line">+ 关注微博 http://weibo.com/houfeng</div></pre></td></tr></table></figure>
<h3 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h3><h5 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ 下载jtp</div><div class="line">+ 将jtp.js或jtp-min.js放到项目中合适的位置。</div><div class="line">+ 在相关页面用&lt;script src=&apos;jtp的url&apos;&gt;&lt;/script&gt;引入jtp。</div></pre></td></tr></table></figure>
<h4 id="解析-jtp-parse"><a href="#解析-jtp-parse" class="headerlink" title="解析(jtp.parse)"></a>解析(jtp.parse)</h4><p>代码:</p>
<pre><code>var html=&apos;&lt;div&gt;My name is &lt;@$(this.name)@&gt;&lt;/div&gt;&apos;;
var rs=jtp.parse(html,{name:&apos;jtp&apos;});
</code></pre><p>结果: </p>
<pre><code>&lt;div&gt;My name is jtp&lt;/div&gt;
</code></pre><h4 id="编译-jtp-complite"><a href="#编译-jtp-complite" class="headerlink" title="编译(jtp.complite)"></a>编译(jtp.complite)</h4><p>代码:</p>
<pre><code>var html=&apos;&lt;div&gt;My name is &lt;@$(this.name)@&gt;&lt;/div&gt;&apos;;
var fn=jtp.complite(html);
var rs=fn({name:&apos;jtp&apos;});
</code></pre><p>结果:</p>
<pre><code>&lt;div&gt;My name is jtp&lt;/div&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;欢迎来到jtp的世界&quot;&gt;&lt;a href=&quot;#欢迎来到jtp的世界&quot; class=&quot;headerlink&quot; title=&quot;欢迎来到jtp的世界&quot;&gt;&lt;/a&gt;欢迎来到jtp的世界&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;欢迎使用jtp! 最轻量，简洁，高效的javascript模板引擎！&lt;br&gt;如同“jtp”的名字，“轻量、简洁、高效”是jtp的哲学！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://blog.houfeng.net/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>移动web开发局部区域滚动问题</title>
    <link href="http://blog.houfeng.net/2012/09/29/mobile-dev-overflow-scroll/"/>
    <id>http://blog.houfeng.net/2012/09/29/mobile-dev-overflow-scroll/</id>
    <published>2012-09-28T16:00:00.000Z</published>
    <updated>2016-08-27T04:30:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>开发一个针对pc的web应用时，在需要不随内容滚动的页头或面页脚时，通常的做法是如下样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.ui-head</span>&#123; <span class="attribute">position</span>:fixed; &#125;</div></pre></td></tr></table></figure></p>
<p>但是如上的样式放到手机上，我测试过android2.x、android4.x、ios4.x皆不支持position:fixed;</p>
<a id="more"></a>
<p>但经过测试，发现ios5.x已经支持position:fiexd,但通过position:fiexd一般只能实现页整的整体滚动时页头或页脚的固定，在实现页面某一小区域的滚动效果还是不太方便。</p>
<p>另外一种方式，是指定一个元素（通常是DIV）的高度或宽度，然后使定义如下样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.ui-content</span> &#123;<span class="attribute">height</span>:<span class="number">300px</span>;<span class="attribute">overflow</span>:auto;&#125;</div></pre></td></tr></table></figure></p>
<p>但经过测试，目前的主流的设备均不支持 overflow 样式。</p>
<h3 id="通过webkit特有的样式实现"><a href="#通过webkit特有的样式实现" class="headerlink" title="通过webkit特有的样式实现"></a>通过webkit特有的样式实现</h3><p>经测试ios5.1已支持如下样式定义：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-webkit-overflow-scrolling</span>: <span class="selector-tag">touch</span>;</div></pre></td></tr></table></figure></p>
<p>通过如上定义，ios5.x可以样式（不用js）实现局部区域滚动；但目前我试过android2.x及android4.x发现依然不支持些样式。</p>
<h3 id="通过javascript实现"><a href="#通过javascript实现" class="headerlink" title="通过javascript实现"></a>通过javascript实现</h3><p>为了实现兼容主流平台及浏览器，常见的做法（很多web开发框架就是依赖javascript实现），如轻量易用的优秀开源组件 iScroll 4 </p>
<p>而通过js实现局部滚动，一般如下几种方式：</p>
<ol>
<li>定义样式 overflow:hidden， 然后处理touchstart、touchmove、touchend事件，控制scrollTop完成滚动功能，此种方式较为简洁，并易于实现。</li>
<li>定义样式 overflow:hidden，并且要求容器内的元素必须有一个内层嵌套外层单一元素比如：<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui-scroll"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui-scroll-inner"</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>然后去控制内层元素的margin-top或margin-left。此种方式稍现麻烦，但可以使用css3的transform2d 控制内层元素translate来实现（此种方法在某些设备上能获得较好的性能）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;开发一个针对pc的web应用时，在需要不随内容滚动的页头或面页脚时，通常的做法是如下样式：&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.ui-head&lt;/span&gt;&amp;#123; &lt;span class=&quot;attribute&quot;&gt;position&lt;/span&gt;:fixed; &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是如上的样式放到手机上，我测试过android2.x、android4.x、ios4.x皆不支持position:fixed;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://blog.houfeng.net/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>linux系统防火墙简单设置</title>
    <link href="http://blog.houfeng.net/2012/09/16/linux-firewall/"/>
    <id>http://blog.houfeng.net/2012/09/16/linux-firewall/</id>
    <published>2012-09-15T16:00:00.000Z</published>
    <updated>2016-08-27T04:30:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux还是比较常用的，于是我研究了一下Linux关闭防火墙命令，在这里拿出来和大家分享一下，希望你能学会Linux关闭防火墙命令 。</p>
<a id="more"></a>
<h3 id="永久性生效，重启后不会复原"><a href="#永久性生效，重启后不会复原" class="headerlink" title="永久性生效，重启后不会复原"></a>永久性生效，重启后不会复原</h3><p>开启： chkconfig iptables on</p>
<p>关闭： chkconfig iptables off</p>
<h3 id="即时生效，重启后复原"><a href="#即时生效，重启后复原" class="headerlink" title="即时生效，重启后复原"></a>即时生效，重启后复原</h3><p>开启： service iptables start</p>
<p>关闭： service iptables stop</p>
<hr>
<p>需要说明的是对于Linux下的其它服务都可以用以上命令执行开启和关闭操作。</p>
<p>在开启了防火墙时，做如下设置，开启相关端口，</p>
<p>修改/etc/sysconfig/iptables 文件，添加以下内容：<br>-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT<br>-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux还是比较常用的，于是我研究了一下Linux关闭防火墙命令，在这里拿出来和大家分享一下，希望你能学会Linux关闭防火墙命令 。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>禁用CentOS Linux系统的图形界面</title>
    <link href="http://blog.houfeng.net/2012/09/15/linux-centos-disabled-gui-start/"/>
    <id>http://blog.houfeng.net/2012/09/15/linux-centos-disabled-gui-start/</id>
    <published>2012-09-14T16:00:00.000Z</published>
    <updated>2016-08-27T04:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何禁用Centos GUI图形界面？</p>
<a id="more"></a>
<p>vi /etc/inittab</p>
<p>把默认的</p>
<p>id:5:initdefault:</p>
<p>改成</p>
<p>id:3:initdefault:</p>
<p>这样登录的默认界面就是字符界面了， 需要gui时， startx 即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何禁用Centos GUI图形界面？&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.houfeng.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
